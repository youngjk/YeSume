{"ast":null,"code":"/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n'use strict';\n\nconst os = require('os');\n\nconst asyncForEach = require('async/forEach');\n\nconst debug = require('diagnostics')('winston:exception');\n\nconst once = require('one-time');\n\nconst stackTrace = require('stack-trace');\n\nconst ExceptionStream = require('./exception-stream');\n/**\n * Object for handling uncaughtException events.\n * @type {ExceptionHandler}\n */\n\n\nmodule.exports = class ExceptionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle exceptions');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n  /**\n   * Handles `uncaughtException` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n\n\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._uncaughtException.bind(this);\n      process.on('uncaughtException', this.catcher);\n    }\n  }\n  /**\n   * Removes any handlers to `uncaughtException` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n\n\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('uncaughtException', this.catcher);\n      this.catcher = false;\n      Array.from(this.handlers.values()).forEach(wrapper => this.logger.unpipe(wrapper));\n    }\n  }\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  getAllInfo(err) {\n    let {\n      message\n    } = err;\n\n    if (!message && typeof err === 'string') {\n      message = err;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [`uncaughtException: ${message || '(no error message)'}`, err.stack || '  No stack trace'].join('\\n'),\n      stack: err.stack,\n      exception: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n\n\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleExceptions = true;\n      const wrapper = new ExceptionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n\n\n  _uncaughtException(err) {\n    const info = this.getAllInfo(err);\n\n    const handlers = this._getExceptionHandlers(); // Calculate if we should exit on this error\n\n\n    let doExit = typeof this.logger.exitOnError === 'function' ? this.logger.exitOnError(err) : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be false with no exception handlers.'); // eslint-disable-next-line no-console\n\n      console.warn('winston: exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any exceptions from transports when\n        // catching uncaught exceptions.\n        if (timeout) {\n          clearTimeout(timeout);\n        } // eslint-disable-next-line no-process-exit\n\n\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    } // Log to all transports attempting to listen for when they are completed.\n\n\n    asyncForEach(handlers, (handler, next) => {\n      // TODO: Change these to the correct WritableStream events so that we\n      // wait until exit.\n      const done = once(next);\n      const transport = handler.transport || handler; // Debug wrapping so that we can inspect what's going on under the covers.\n\n      function onDone(event) {\n        return () => {\n          debug(event);\n          done();\n        };\n      }\n\n      transport.once('logged', onDone('logged'));\n      transport.once('error', onDone('error'));\n    }, gracefulExit);\n    this.logger.log(info); // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n\n\n  _getExceptionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleExceptions: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleExceptions;\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/winston/lib/winston/exception-handler.js"],"names":["os","require","asyncForEach","debug","once","stackTrace","ExceptionStream","module","exports","ExceptionHandler","constructor","logger","Error","handlers","Map","handle","args","forEach","arg","Array","isArray","handler","_addHandler","catcher","_uncaughtException","bind","process","on","unhandle","removeListener","from","values","wrapper","unpipe","getAllInfo","err","message","error","level","stack","join","exception","date","Date","toString","getProcessInfo","getOsInfo","trace","getTrace","pid","uid","getuid","gid","getgid","cwd","execPath","version","argv","memoryUsage","loadavg","uptime","parse","get","map","site","column","getColumnNumber","file","getFileName","function","getFunctionName","line","getLineNumber","method","getMethodName","native","isNative","has","handleExceptions","set","pipe","info","_getExceptionHandlers","doExit","exitOnError","timeout","length","console","warn","gracefulExit","_exiting","clearTimeout","exit","nextTick","next","done","transport","onDone","event","log","setTimeout","transports","filter","wrap"],"mappings":"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","sourcesContent":["/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nconst os = require('os');\nconst asyncForEach = require('async/forEach');\nconst debug = require('diagnostics')('winston:exception');\nconst once = require('one-time');\nconst stackTrace = require('stack-trace');\nconst ExceptionStream = require('./exception-stream');\n\n/**\n * Object for handling uncaughtException events.\n * @type {ExceptionHandler}\n */\nmodule.exports = class ExceptionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle exceptions');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `uncaughtException` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._uncaughtException.bind(this);\n      process.on('uncaughtException', this.catcher);\n    }\n  }\n\n  /**\n   * Removes any handlers to `uncaughtException` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('uncaughtException', this.catcher);\n      this.catcher = false;\n\n      Array.from(this.handlers.values())\n        .forEach(wrapper => this.logger.unpipe(wrapper));\n    }\n  }\n\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getAllInfo(err) {\n    let { message } = err;\n    if (!message && typeof err === 'string') {\n      message = err;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [\n        `uncaughtException: ${(message || '(no error message)')}`,\n        err.stack || '  No stack trace'\n      ].join('\\n'),\n      stack: err.stack,\n      exception: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleExceptions = true;\n      const wrapper = new ExceptionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _uncaughtException(err) {\n    const info = this.getAllInfo(err);\n    const handlers = this._getExceptionHandlers();\n    // Calculate if we should exit on this error\n    let doExit = typeof this.logger.exitOnError === 'function'\n      ? this.logger.exitOnError(err)\n      : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be false with no exception handlers.');\n      // eslint-disable-next-line no-console\n      console.warn('winston: exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any exceptions from transports when\n        // catching uncaught exceptions.\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    }\n\n    // Log to all transports attempting to listen for when they are completed.\n    asyncForEach(handlers, (handler, next) => {\n      // TODO: Change these to the correct WritableStream events so that we\n      // wait until exit.\n      const done = once(next);\n      const transport = handler.transport || handler;\n\n      // Debug wrapping so that we can inspect what's going on under the covers.\n      function onDone(event) {\n        return () => {\n          debug(event);\n          done();\n        };\n      }\n\n      transport.once('logged', onDone('logged'));\n      transport.once('error', onDone('error'));\n    }, gracefulExit);\n\n    this.logger.log(info);\n\n    // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n  _getExceptionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleExceptions: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleExceptions;\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"module"}