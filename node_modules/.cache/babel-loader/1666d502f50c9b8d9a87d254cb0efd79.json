{"ast":null,"code":"const puppeteer = require('puppeteer');\n\nconst login = require('./login');\n\nconst profile = require('./profile/profile');\n\nconst company = require('./company/company');\n\nconst logger = require('./logger')(__filename);\n\nmodule.exports = async ({\n  cookies,\n  email,\n  password,\n  isHeadless,\n  hasToLog,\n  hasToGetContactInfo,\n  puppeteerArgs,\n  puppeteerAuthenticate,\n  endpoint\n} = {\n  isHeadless: true,\n  hasToLog: false\n}) => {\n  if (!hasToLog) {\n    logger.stopLogging();\n  }\n\n  logger.info('initializing');\n  let browser;\n\n  if (endpoint) {\n    browser = await puppeteer.connect({\n      browserWSEndpoint: endpoint\n    });\n  } else {\n    const args = Object.assign({\n      headless: isHeadless,\n      args: ['--no-sandbox']\n    }, puppeteerArgs);\n    browser = await puppeteer.launch(args);\n  }\n\n  if (cookies) {\n    logger.info('using cookies, login will be bypassed');\n  } else if (email && password) {\n    logger.info('email and password was provided, we\\'re going to login...');\n\n    try {\n      await login(browser, email, password, logger);\n    } catch (e) {\n      if (!endpoint) {\n        await browser.close();\n      }\n\n      throw e;\n    }\n  } else {\n    logger.warn('email/password and cookies wasn\\'t provided, only public data will be collected');\n  }\n\n  return (url, waitMs) => url.includes('/school/') || url.includes('/company/') ? company(browser, cookies, url, waitMs, hasToGetContactInfo, puppeteerAuthenticate) : profile(browser, cookies, url, waitMs, hasToGetContactInfo, puppeteerAuthenticate);\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/scrapedin/src/scrapedin.js"],"names":["puppeteer","require","login","profile","company","logger","__filename","module","exports","cookies","email","password","isHeadless","hasToLog","hasToGetContactInfo","puppeteerArgs","puppeteerAuthenticate","endpoint","stopLogging","info","browser","connect","browserWSEndpoint","args","Object","assign","headless","launch","e","close","warn","url","waitMs","includes"],"mappings":"AAAA,MAAMA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAP,CAAoBK,UAApB,CAAf;;AAEAC,MAAM,CAACC,OAAP,GAAiB,OAAO;AAAEC,EAAAA,OAAF;AAAWC,EAAAA,KAAX;AAAkBC,EAAAA,QAAlB;AAA4BC,EAAAA,UAA5B;AAAwCC,EAAAA,QAAxC;AAAkDC,EAAAA,mBAAlD;AAAuEC,EAAAA,aAAvE;AAAsFC,EAAAA,qBAAtF;AAA6GC,EAAAA;AAA7G,IAA0H;AAAEL,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,QAAQ,EAAE;AAA9B,CAAjI,KAA2K;AAC1L,MAAI,CAACA,QAAL,EAAe;AACbR,IAAAA,MAAM,CAACa,WAAP;AACD;;AACDb,EAAAA,MAAM,CAACc,IAAP,CAAY,cAAZ;AAEA,MAAIC,OAAJ;;AACA,MAAGH,QAAH,EAAY;AACVG,IAAAA,OAAO,GAAG,MAAMpB,SAAS,CAACqB,OAAV,CAAkB;AAChCC,MAAAA,iBAAiB,EAAEL;AADa,KAAlB,CAAhB;AAGD,GAJD,MAIK;AACH,UAAMM,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAAA,QAAQ,EAAEd,UAAZ;AAAwBW,MAAAA,IAAI,EAAE,CAAC,cAAD;AAA9B,KAAd,EAAgER,aAAhE,CAAb;AACAK,IAAAA,OAAO,GAAG,MAAMpB,SAAS,CAAC2B,MAAV,CAAiBJ,IAAjB,CAAhB;AACD;;AAED,MAAId,OAAJ,EAAa;AACXJ,IAAAA,MAAM,CAACc,IAAP,CAAY,uCAAZ;AACD,GAFD,MAEO,IAAIT,KAAK,IAAIC,QAAb,EAAuB;AAC5BN,IAAAA,MAAM,CAACc,IAAP,CAAY,2DAAZ;;AAEA,QAAI;AACF,YAAMjB,KAAK,CAACkB,OAAD,EAAUV,KAAV,EAAiBC,QAAjB,EAA2BN,MAA3B,CAAX;AACD,KAFD,CAEE,OAAOuB,CAAP,EAAU;AACV,UAAG,CAACX,QAAJ,EAAa;AACX,cAAMG,OAAO,CAACS,KAAR,EAAN;AACD;;AACD,YAAMD,CAAN;AACD;AACF,GAXM,MAWA;AACLvB,IAAAA,MAAM,CAACyB,IAAP,CAAY,iFAAZ;AACD;;AAED,SAAO,CAACC,GAAD,EAAMC,MAAN,KAAiBD,GAAG,CAACE,QAAJ,CAAa,UAAb,KAA4BF,GAAG,CAACE,QAAJ,CAAa,WAAb,CAA5B,GAAwD7B,OAAO,CAACgB,OAAD,EAAUX,OAAV,EAAmBsB,GAAnB,EAAwBC,MAAxB,EAAgClB,mBAAhC,EAAqDE,qBAArD,CAA/D,GAA4Ib,OAAO,CAACiB,OAAD,EAAUX,OAAV,EAAmBsB,GAAnB,EAAwBC,MAAxB,EAAgClB,mBAAhC,EAAqDE,qBAArD,CAA3K;AACD,CAlCD","sourcesContent":["const puppeteer = require('puppeteer')\nconst login = require('./login')\nconst profile = require('./profile/profile')\nconst company = require('./company/company')\nconst logger = require('./logger')(__filename)\n\nmodule.exports = async ({ cookies, email, password, isHeadless, hasToLog, hasToGetContactInfo, puppeteerArgs, puppeteerAuthenticate, endpoint } = { isHeadless: true, hasToLog: false }) => {\n  if (!hasToLog) {\n    logger.stopLogging()\n  }\n  logger.info('initializing')\n\n  let browser;\n  if(endpoint){\n    browser = await puppeteer.connect({\n      browserWSEndpoint: endpoint,\n    });\n  }else{\n    const args = Object.assign({ headless: isHeadless, args: ['--no-sandbox'] }, puppeteerArgs)\n    browser = await puppeteer.launch(args)\n  }\n\n  if (cookies) {\n    logger.info('using cookies, login will be bypassed')\n  } else if (email && password) {\n    logger.info('email and password was provided, we\\'re going to login...')\n\n    try {\n      await login(browser, email, password, logger)\n    } catch (e) {\n      if(!endpoint){\n        await browser.close()\n      }\n      throw e\n    }\n  } else {\n    logger.warn('email/password and cookies wasn\\'t provided, only public data will be collected')\n  }\n\n  return (url, waitMs) => url.includes('/school/') || url.includes('/company/') ? company(browser, cookies, url, waitMs, hasToGetContactInfo, puppeteerAuthenticate) :profile(browser, cookies, url, waitMs, hasToGetContactInfo, puppeteerAuthenticate)\n}\n"]},"metadata":{},"sourceType":"module"}