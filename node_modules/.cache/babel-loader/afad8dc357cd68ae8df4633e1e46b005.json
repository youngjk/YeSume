{"ast":null,"code":"/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst fs = require('fs');\n\nconst {\n  helper,\n  assert\n} = require('./helper');\n\nconst {\n  LifecycleWatcher\n} = require('./LifecycleWatcher');\n\nconst {\n  TimeoutError\n} = require('./Errors');\n\nconst readFileAsync = helper.promisify(fs.readFile);\n/**\n * @unrestricted\n */\n\nclass DOMWorld {\n  /**\n   * @param {!Puppeteer.FrameManager} frameManager\n   * @param {!Puppeteer.Frame} frame\n   * @param {!Puppeteer.TimeoutSettings} timeoutSettings\n   */\n  constructor(frameManager, frame, timeoutSettings) {\n    this._frameManager = frameManager;\n    this._frame = frame;\n    this._timeoutSettings = timeoutSettings;\n    /** @type {?Promise<!Puppeteer.ElementHandle>} */\n\n    this._documentPromise = null;\n    /** @type {!Promise<!Puppeteer.ExecutionContext>} */\n\n    this._contextPromise;\n    this._contextResolveCallback = null;\n\n    this._setContext(null);\n    /** @type {!Set<!WaitTask>} */\n\n\n    this._waitTasks = new Set();\n    this._detached = false;\n  }\n  /**\n   * @return {!Puppeteer.Frame}\n   */\n\n\n  frame() {\n    return this._frame;\n  }\n  /**\n   * @param {?Puppeteer.ExecutionContext} context\n   */\n\n\n  _setContext(context) {\n    if (context) {\n      this._contextResolveCallback.call(null, context);\n\n      this._contextResolveCallback = null;\n\n      for (const waitTask of this._waitTasks) waitTask.rerun();\n    } else {\n      this._documentPromise = null;\n      this._contextPromise = new Promise(fulfill => {\n        this._contextResolveCallback = fulfill;\n      });\n    }\n  }\n\n  _detach() {\n    this._detached = true;\n\n    for (const waitTask of this._waitTasks) waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n  }\n  /**\n   * @return {!Promise<!Puppeteer.ExecutionContext>}\n   */\n\n\n  executionContext() {\n    if (this._detached) throw new Error(`Execution Context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n    return this._contextPromise;\n  }\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<*>}\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluate(pageFunction, ...args);\n  }\n  /**\n   * @param {string} selector\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n\n\n  async $(selector) {\n    const document = await this._document();\n    const value = await document.$(selector);\n    return value;\n  }\n  /**\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n\n\n  async _document() {\n    if (this._documentPromise) return this._documentPromise;\n    this._documentPromise = this.executionContext().then(async context => {\n      const document = await context.evaluateHandle('document');\n      return document.asElement();\n    });\n    return this._documentPromise;\n  }\n  /**\n   * @param {string} expression\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n\n\n  async $x(expression) {\n    const document = await this._document();\n    const value = await document.$x(expression);\n    return value;\n  }\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n\n\n  async $eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n\n\n  async $$eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    const value = await document.$$eval(selector, pageFunction, ...args);\n    return value;\n  }\n  /**\n   * @param {string} selector\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n\n\n  async $$(selector) {\n    const document = await this._document();\n    const value = await document.$$(selector);\n    return value;\n  }\n  /**\n   * @return {!Promise<String>}\n   */\n\n\n  async content() {\n    return await this.evaluate(() => {\n      let retVal = '';\n      if (document.doctype) retVal = new XMLSerializer().serializeToString(document.doctype);\n      if (document.documentElement) retVal += document.documentElement.outerHTML;\n      return retVal;\n    });\n  }\n  /**\n   * @param {string} html\n   * @param {!{timeout?: number, waitUntil?: string|!Array<string>}=} options\n   */\n\n\n  async setContent(html, options = {}) {\n    const {\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options; // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n    // lifecycle event. @see https://crrev.com/608658\n\n    await this.evaluate(html => {\n      document.open();\n      document.write(html);\n      document.close();\n    }, html);\n    const watcher = new LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);\n    const error = await Promise.race([watcher.timeoutOrTerminationPromise(), watcher.lifecyclePromise()]);\n    watcher.dispose();\n    if (error) throw error;\n  }\n  /**\n   * @param {!{url?: string, path?: string, content?: string, type?: string}} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n\n\n  async addScriptTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null,\n      type = ''\n    } = options;\n\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();\n      } catch (error) {\n        throw new Error(`Loading script from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      let contents = await readFileAsync(path, 'utf8');\n      contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, content, type)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n    /**\n     * @param {string} url\n     * @param {string} type\n     * @return {!Promise<!HTMLElement>}\n     */\n\n    async function addScriptUrl(url, type) {\n      const script = document.createElement('script');\n      script.src = url;\n      if (type) script.type = type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = rej;\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n    /**\n     * @param {string} content\n     * @param {string} type\n     * @return {!HTMLElement}\n     */\n\n\n    function addScriptContent(content, type = 'text/javascript') {\n      const script = document.createElement('script');\n      script.type = type;\n      script.text = content;\n      let error = null;\n\n      script.onerror = e => error = e;\n\n      document.head.appendChild(script);\n      if (error) throw error;\n      return script;\n    }\n  }\n  /**\n   * @param {!{url?: string, path?: string, content?: string}} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n\n\n  async addStyleTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null\n    } = options;\n\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n      } catch (error) {\n        throw new Error(`Loading style from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      let contents = await readFileAsync(path, 'utf8');\n      contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, content)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n    /**\n     * @param {string} url\n     * @return {!Promise<!HTMLElement>}\n     */\n\n    async function addStyleUrl(url) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n    /**\n     * @param {string} content\n     * @return {!Promise<!HTMLElement>}\n     */\n\n\n    async function addStyleContent(content) {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n  /**\n   * @param {string} selector\n   * @param {!{delay?: number, button?: \"left\"|\"right\"|\"middle\", clickCount?: number}=} options\n   */\n\n\n  async click(selector, options) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.click(options);\n    await handle.dispose();\n  }\n  /**\n   * @param {string} selector\n   */\n\n\n  async focus(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.focus();\n    await handle.dispose();\n  }\n  /**\n   * @param {string} selector\n   */\n\n\n  async hover(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.hover();\n    await handle.dispose();\n  }\n  /**\n  * @param {string} selector\n  * @param {!Array<string>} values\n  * @return {!Promise<!Array<string>>}\n  */\n\n\n  select(selector, ...values) {\n    for (const value of values) assert(helper.isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n\n    return this.$eval(selector, (element, values) => {\n      if (element.nodeName.toLowerCase() !== 'select') throw new Error('Element is not a <select> element.');\n      const options = Array.from(element.options);\n      element.value = undefined;\n\n      for (const option of options) {\n        option.selected = values.includes(option.value);\n        if (option.selected && !element.multiple) break;\n      }\n\n      element.dispatchEvent(new Event('input', {\n        'bubbles': true\n      }));\n      element.dispatchEvent(new Event('change', {\n        'bubbles': true\n      }));\n      return options.filter(option => option.selected).map(option => option.value);\n    }, values);\n  }\n  /**\n   * @param {string} selector\n   */\n\n\n  async tap(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.tap();\n    await handle.dispose();\n  }\n  /**\n   * @param {string} selector\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n\n\n  async type(selector, text, options) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n  /**\n   * @param {string} selector\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n\n\n  waitForSelector(selector, options) {\n    return this._waitForSelectorOrXPath(selector, false, options);\n  }\n  /**\n   * @param {string} xpath\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n\n\n  waitForXPath(xpath, options) {\n    return this._waitForSelectorOrXPath(xpath, true, options);\n  }\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!{polling?: string|number, timeout?: number}=} options\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    return new WaitTask(this, pageFunction, 'function', polling, timeout, ...args).promise;\n  }\n  /**\n   * @return {!Promise<string>}\n   */\n\n\n  async title() {\n    return this.evaluate(() => document.title);\n  }\n  /**\n   * @param {string} selectorOrXPath\n   * @param {boolean} isXPath\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n\n\n  async _waitForSelectorOrXPath(selectorOrXPath, isXPath, options = {}) {\n    const {\n      visible: waitForVisible = false,\n      hidden: waitForHidden = false,\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n    const title = `${isXPath ? 'XPath' : 'selector'} \"${selectorOrXPath}\"${waitForHidden ? ' to be hidden' : ''}`;\n    const waitTask = new WaitTask(this, predicate, title, polling, timeout, selectorOrXPath, isXPath, waitForVisible, waitForHidden);\n    const handle = await waitTask.promise;\n\n    if (!handle.asElement()) {\n      await handle.dispose();\n      return null;\n    }\n\n    return handle.asElement();\n    /**\n     * @param {string} selectorOrXPath\n     * @param {boolean} isXPath\n     * @param {boolean} waitForVisible\n     * @param {boolean} waitForHidden\n     * @return {?Node|boolean}\n     */\n\n    function predicate(selectorOrXPath, isXPath, waitForVisible, waitForHidden) {\n      const node = isXPath ? document.evaluate(selectorOrXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue : document.querySelector(selectorOrXPath);\n      if (!node) return waitForHidden;\n      if (!waitForVisible && !waitForHidden) return node;\n      const element =\n      /** @type {Element} */\n      node.nodeType === Node.TEXT_NODE ? node.parentElement : node;\n      const style = window.getComputedStyle(element);\n      const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();\n      const success = waitForVisible === isVisible || waitForHidden === !isVisible;\n      return success ? node : null;\n      /**\n       * @return {boolean}\n       */\n\n      function hasVisibleBoundingBox() {\n        const rect = element.getBoundingClientRect();\n        return !!(rect.top || rect.bottom || rect.width || rect.height);\n      }\n    }\n  }\n\n}\n\nclass WaitTask {\n  /**\n   * @param {!DOMWorld} domWorld\n   * @param {Function|string} predicateBody\n   * @param {string|number} polling\n   * @param {number} timeout\n   * @param {!Array<*>} args\n   */\n  constructor(domWorld, predicateBody, title, polling, timeout, ...args) {\n    if (helper.isString(polling)) assert(polling === 'raf' || polling === 'mutation', 'Unknown polling option: ' + polling);else if (helper.isNumber(polling)) assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);else throw new Error('Unknown polling options: ' + polling);\n    this._domWorld = domWorld;\n    this._polling = polling;\n    this._timeout = timeout;\n    this._predicateBody = helper.isString(predicateBody) ? 'return (' + predicateBody + ')' : 'return (' + predicateBody + ')(...args)';\n    this._args = args;\n    this._runCount = 0;\n\n    domWorld._waitTasks.add(this);\n\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    }); // Since page navigation requires us to re-install the pageScript, we should track\n    // timeout on our end.\n\n    if (timeout) {\n      const timeoutError = new TimeoutError(`waiting for ${title} failed: timeout ${timeout}ms exceeded`);\n      this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);\n    }\n\n    this.rerun();\n  }\n  /**\n   * @param {!Error} error\n   */\n\n\n  terminate(error) {\n    this._terminated = true;\n\n    this._reject(error);\n\n    this._cleanup();\n  }\n\n  async rerun() {\n    const runCount = ++this._runCount;\n    /** @type {?Puppeteer.JSHandle} */\n\n    let success = null;\n    let error = null;\n\n    try {\n      success = await (await this._domWorld.executionContext()).evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n    } catch (e) {\n      error = e;\n    }\n\n    if (this._terminated || runCount !== this._runCount) {\n      if (success) await success.dispose();\n      return;\n    } // Ignore timeouts in pageScript - we track timeouts ourselves.\n    // If the frame's execution context has already changed, `frame.evaluate` will\n    // throw an error - ignore this predicate run altogether.\n\n\n    if (!error && (await this._domWorld.evaluate(s => !s, success).catch(e => true))) {\n      await success.dispose();\n      return;\n    } // When the page is navigated, the promise is rejected.\n    // We will try again in the new execution context.\n\n\n    if (error && error.message.includes('Execution context was destroyed')) return; // We could have tried to evaluate in a context which was already\n    // destroyed.\n\n    if (error && error.message.includes('Cannot find context with specified id')) return;\n    if (error) this._reject(error);else this._resolve(success);\n\n    this._cleanup();\n  }\n\n  _cleanup() {\n    clearTimeout(this._timeoutTimer);\n\n    this._domWorld._waitTasks.delete(this);\n\n    this._runningTask = null;\n  }\n\n}\n/**\n * @param {string} predicateBody\n * @param {string} polling\n * @param {number} timeout\n * @return {!Promise<*>}\n */\n\n\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n  const predicate = new Function('...args', predicateBody);\n  let timedOut = false;\n  if (timeout) setTimeout(() => timedOut = true, timeout);\n  if (polling === 'raf') return await pollRaf();\n  if (polling === 'mutation') return await pollMutation();\n  if (typeof polling === 'number') return await pollInterval(polling);\n  /**\n   * @return {!Promise<*>}\n   */\n\n  function pollMutation() {\n    const success = predicate.apply(null, args);\n    if (success) return Promise.resolve(success);\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    const observer = new MutationObserver(mutations => {\n      if (timedOut) {\n        observer.disconnect();\n        fulfill();\n      }\n\n      const success = predicate.apply(null, args);\n\n      if (success) {\n        observer.disconnect();\n        fulfill(success);\n      }\n    });\n    observer.observe(document, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return result;\n  }\n  /**\n   * @return {!Promise<*>}\n   */\n\n\n  function pollRaf() {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onRaf();\n    return result;\n\n    function onRaf() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n\n      const success = predicate.apply(null, args);\n      if (success) fulfill(success);else requestAnimationFrame(onRaf);\n    }\n  }\n  /**\n   * @param {number} pollInterval\n   * @return {!Promise<*>}\n   */\n\n\n  function pollInterval(pollInterval) {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onTimeout();\n    return result;\n\n    function onTimeout() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n\n      const success = predicate.apply(null, args);\n      if (success) fulfill(success);else setTimeout(onTimeout, pollInterval);\n    }\n  }\n}\n\nmodule.exports = {\n  DOMWorld\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/puppeteer/lib/DOMWorld.js"],"names":["fs","require","helper","assert","LifecycleWatcher","TimeoutError","readFileAsync","promisify","readFile","DOMWorld","constructor","frameManager","frame","timeoutSettings","_frameManager","_frame","_timeoutSettings","_documentPromise","_contextPromise","_contextResolveCallback","_setContext","_waitTasks","Set","_detached","context","call","waitTask","rerun","Promise","fulfill","_detach","terminate","Error","executionContext","url","evaluateHandle","pageFunction","args","evaluate","$","selector","document","_document","value","then","asElement","$x","expression","$eval","$$eval","$$","content","retVal","doctype","XMLSerializer","serializeToString","documentElement","outerHTML","setContent","html","options","waitUntil","timeout","navigationTimeout","open","write","close","watcher","error","race","timeoutOrTerminationPromise","lifecyclePromise","dispose","addScriptTag","path","type","addScriptUrl","contents","replace","addScriptContent","script","createElement","src","promise","res","rej","onload","onerror","head","appendChild","text","e","addStyleTag","addStyleUrl","addStyleContent","link","rel","href","style","createTextNode","click","handle","focus","hover","select","values","isString","element","nodeName","toLowerCase","Array","from","undefined","option","selected","includes","multiple","dispatchEvent","Event","filter","map","tap","waitForSelector","_waitForSelectorOrXPath","waitForXPath","xpath","waitForFunction","polling","WaitTask","title","selectorOrXPath","isXPath","visible","waitForVisible","hidden","waitForHidden","predicate","node","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","querySelector","nodeType","Node","TEXT_NODE","parentElement","window","getComputedStyle","isVisible","visibility","hasVisibleBoundingBox","success","rect","getBoundingClientRect","top","bottom","width","height","domWorld","predicateBody","isNumber","_domWorld","_polling","_timeout","_predicateBody","_args","_runCount","add","resolve","reject","_resolve","_reject","timeoutError","_timeoutTimer","setTimeout","_terminated","_cleanup","runCount","waitForPredicatePageFunction","s","catch","message","clearTimeout","delete","_runningTask","Function","timedOut","pollRaf","pollMutation","pollInterval","apply","result","x","observer","MutationObserver","mutations","disconnect","observe","childList","subtree","attributes","onRaf","requestAnimationFrame","onTimeout","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst fs = require('fs');\nconst {helper, assert} = require('./helper');\nconst {LifecycleWatcher} = require('./LifecycleWatcher');\nconst {TimeoutError} = require('./Errors');\nconst readFileAsync = helper.promisify(fs.readFile);\n\n/**\n * @unrestricted\n */\nclass DOMWorld {\n  /**\n   * @param {!Puppeteer.FrameManager} frameManager\n   * @param {!Puppeteer.Frame} frame\n   * @param {!Puppeteer.TimeoutSettings} timeoutSettings\n   */\n  constructor(frameManager, frame, timeoutSettings) {\n    this._frameManager = frameManager;\n    this._frame = frame;\n    this._timeoutSettings = timeoutSettings;\n\n    /** @type {?Promise<!Puppeteer.ElementHandle>} */\n    this._documentPromise = null;\n    /** @type {!Promise<!Puppeteer.ExecutionContext>} */\n    this._contextPromise;\n    this._contextResolveCallback = null;\n    this._setContext(null);\n\n    /** @type {!Set<!WaitTask>} */\n    this._waitTasks = new Set();\n    this._detached = false;\n  }\n\n  /**\n   * @return {!Puppeteer.Frame}\n   */\n  frame() {\n    return this._frame;\n  }\n\n  /**\n   * @param {?Puppeteer.ExecutionContext} context\n   */\n  _setContext(context) {\n    if (context) {\n      this._contextResolveCallback.call(null, context);\n      this._contextResolveCallback = null;\n      for (const waitTask of this._waitTasks)\n        waitTask.rerun();\n    } else {\n      this._documentPromise = null;\n      this._contextPromise = new Promise(fulfill => {\n        this._contextResolveCallback = fulfill;\n      });\n    }\n  }\n\n  _detach() {\n    this._detached = true;\n    for (const waitTask of this._waitTasks)\n      waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n  }\n\n  /**\n   * @return {!Promise<!Puppeteer.ExecutionContext>}\n   */\n  executionContext() {\n    if (this._detached)\n      throw new Error(`Execution Context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n    return this._contextPromise;\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<*>}\n   */\n  async evaluate(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n  async $(selector) {\n    const document = await this._document();\n    const value = await document.$(selector);\n    return value;\n  }\n\n  /**\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n  async _document() {\n    if (this._documentPromise)\n      return this._documentPromise;\n    this._documentPromise = this.executionContext().then(async context => {\n      const document = await context.evaluateHandle('document');\n      return document.asElement();\n    });\n    return this._documentPromise;\n  }\n\n  /**\n   * @param {string} expression\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n  async $x(expression) {\n    const document = await this._document();\n    const value = await document.$x(expression);\n    return value;\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * @param {string} selector\n   * @param {Function|string} pageFunction\n   * @param {!Array<*>} args\n   * @return {!Promise<(!Object|undefined)>}\n   */\n  async $$eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    const value = await document.$$eval(selector, pageFunction, ...args);\n    return value;\n  }\n\n  /**\n   * @param {string} selector\n   * @return {!Promise<!Array<!Puppeteer.ElementHandle>>}\n   */\n  async $$(selector) {\n    const document = await this._document();\n    const value = await document.$$(selector);\n    return value;\n  }\n\n  /**\n   * @return {!Promise<String>}\n   */\n  async content() {\n    return await this.evaluate(() => {\n      let retVal = '';\n      if (document.doctype)\n        retVal = new XMLSerializer().serializeToString(document.doctype);\n      if (document.documentElement)\n        retVal += document.documentElement.outerHTML;\n      return retVal;\n    });\n  }\n\n  /**\n   * @param {string} html\n   * @param {!{timeout?: number, waitUntil?: string|!Array<string>}=} options\n   */\n  async setContent(html, options = {}) {\n    const {\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout(),\n    } = options;\n    // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n    // lifecycle event. @see https://crrev.com/608658\n    await this.evaluate(html => {\n      document.open();\n      document.write(html);\n      document.close();\n    }, html);\n    const watcher = new LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);\n    const error = await Promise.race([\n      watcher.timeoutOrTerminationPromise(),\n      watcher.lifecyclePromise(),\n    ]);\n    watcher.dispose();\n    if (error)\n      throw error;\n  }\n\n  /**\n   * @param {!{url?: string, path?: string, content?: string, type?: string}} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n  async addScriptTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null,\n      type = ''\n    } = options;\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();\n      } catch (error) {\n        throw new Error(`Loading script from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      let contents = await readFileAsync(path, 'utf8');\n      contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, content, type)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    /**\n     * @param {string} url\n     * @param {string} type\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addScriptUrl(url, type) {\n      const script = document.createElement('script');\n      script.src = url;\n      if (type)\n        script.type = type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = rej;\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n\n    /**\n     * @param {string} content\n     * @param {string} type\n     * @return {!HTMLElement}\n     */\n    function addScriptContent(content, type = 'text/javascript') {\n      const script = document.createElement('script');\n      script.type = type;\n      script.text = content;\n      let error = null;\n      script.onerror = e => error = e;\n      document.head.appendChild(script);\n      if (error)\n        throw error;\n      return script;\n    }\n  }\n\n  /**\n   * @param {!{url?: string, path?: string, content?: string}} options\n   * @return {!Promise<!Puppeteer.ElementHandle>}\n   */\n  async addStyleTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null\n    } = options;\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n      } catch (error) {\n        throw new Error(`Loading style from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      let contents = await readFileAsync(path, 'utf8');\n      contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, content)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    /**\n     * @param {string} url\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addStyleUrl(url) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n\n    /**\n     * @param {string} content\n     * @return {!Promise<!HTMLElement>}\n     */\n    async function addStyleContent(content) {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!{delay?: number, button?: \"left\"|\"right\"|\"middle\", clickCount?: number}=} options\n   */\n  async click(selector, options) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async focus(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.focus();\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async hover(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.hover();\n    await handle.dispose();\n  }\n\n  /**\n  * @param {string} selector\n  * @param {!Array<string>} values\n  * @return {!Promise<!Array<string>>}\n  */\n  select(selector, ...values){\n    for (const value of values)\n      assert(helper.isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + (typeof value) + '\"');\n    return this.$eval(selector, (element, values) => {\n      if (element.nodeName.toLowerCase() !== 'select')\n        throw new Error('Element is not a <select> element.');\n\n      const options = Array.from(element.options);\n      element.value = undefined;\n      for (const option of options) {\n        option.selected = values.includes(option.value);\n        if (option.selected && !element.multiple)\n          break;\n      }\n      element.dispatchEvent(new Event('input', { 'bubbles': true }));\n      element.dispatchEvent(new Event('change', { 'bubbles': true }));\n      return options.filter(option => option.selected).map(option => option.value);\n    }, values);\n  }\n\n  /**\n   * @param {string} selector\n   */\n  async tap(selector) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.tap();\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   * @param {string} text\n   * @param {{delay: (number|undefined)}=} options\n   */\n  async type(selector, text, options) {\n    const handle = await this.$(selector);\n    assert(handle, 'No node found for selector: ' + selector);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n\n  /**\n   * @param {string} selector\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n  waitForSelector(selector, options) {\n    return this._waitForSelectorOrXPath(selector, false, options);\n  }\n\n  /**\n   * @param {string} xpath\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n  waitForXPath(xpath, options) {\n    return this._waitForSelectorOrXPath(xpath, true, options);\n  }\n\n  /**\n   * @param {Function|string} pageFunction\n   * @param {!{polling?: string|number, timeout?: number}=} options\n   * @return {!Promise<!Puppeteer.JSHandle>}\n   */\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this._timeoutSettings.timeout(),\n    } = options;\n    return new WaitTask(this, pageFunction, 'function', polling, timeout, ...args).promise;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async title() {\n    return this.evaluate(() => document.title);\n  }\n\n  /**\n   * @param {string} selectorOrXPath\n   * @param {boolean} isXPath\n   * @param {!{visible?: boolean, hidden?: boolean, timeout?: number}=} options\n   * @return {!Promise<?Puppeteer.ElementHandle>}\n   */\n  async _waitForSelectorOrXPath(selectorOrXPath, isXPath, options = {}) {\n    const {\n      visible: waitForVisible = false,\n      hidden: waitForHidden = false,\n      timeout = this._timeoutSettings.timeout(),\n    } = options;\n    const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n    const title = `${isXPath ? 'XPath' : 'selector'} \"${selectorOrXPath}\"${waitForHidden ? ' to be hidden' : ''}`;\n    const waitTask = new WaitTask(this, predicate, title, polling, timeout, selectorOrXPath, isXPath, waitForVisible, waitForHidden);\n    const handle = await waitTask.promise;\n    if (!handle.asElement()) {\n      await handle.dispose();\n      return null;\n    }\n    return handle.asElement();\n\n    /**\n     * @param {string} selectorOrXPath\n     * @param {boolean} isXPath\n     * @param {boolean} waitForVisible\n     * @param {boolean} waitForHidden\n     * @return {?Node|boolean}\n     */\n    function predicate(selectorOrXPath, isXPath, waitForVisible, waitForHidden) {\n      const node = isXPath\n        ? document.evaluate(selectorOrXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue\n        : document.querySelector(selectorOrXPath);\n      if (!node)\n        return waitForHidden;\n      if (!waitForVisible && !waitForHidden)\n        return node;\n      const element = /** @type {Element} */ (node.nodeType === Node.TEXT_NODE ? node.parentElement : node);\n\n      const style = window.getComputedStyle(element);\n      const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();\n      const success = (waitForVisible === isVisible || waitForHidden === !isVisible);\n      return success ? node : null;\n\n      /**\n       * @return {boolean}\n       */\n      function hasVisibleBoundingBox() {\n        const rect = element.getBoundingClientRect();\n        return !!(rect.top || rect.bottom || rect.width || rect.height);\n      }\n    }\n  }\n}\n\nclass WaitTask {\n  /**\n   * @param {!DOMWorld} domWorld\n   * @param {Function|string} predicateBody\n   * @param {string|number} polling\n   * @param {number} timeout\n   * @param {!Array<*>} args\n   */\n  constructor(domWorld, predicateBody, title, polling, timeout, ...args) {\n    if (helper.isString(polling))\n      assert(polling === 'raf' || polling === 'mutation', 'Unknown polling option: ' + polling);\n    else if (helper.isNumber(polling))\n      assert(polling > 0, 'Cannot poll with non-positive interval: ' + polling);\n    else\n      throw new Error('Unknown polling options: ' + polling);\n\n    this._domWorld = domWorld;\n    this._polling = polling;\n    this._timeout = timeout;\n    this._predicateBody = helper.isString(predicateBody) ? 'return (' + predicateBody + ')' : 'return (' + predicateBody + ')(...args)';\n    this._args = args;\n    this._runCount = 0;\n    domWorld._waitTasks.add(this);\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    // Since page navigation requires us to re-install the pageScript, we should track\n    // timeout on our end.\n    if (timeout) {\n      const timeoutError = new TimeoutError(`waiting for ${title} failed: timeout ${timeout}ms exceeded`);\n      this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);\n    }\n    this.rerun();\n  }\n\n  /**\n   * @param {!Error} error\n   */\n  terminate(error) {\n    this._terminated = true;\n    this._reject(error);\n    this._cleanup();\n  }\n\n  async rerun() {\n    const runCount = ++this._runCount;\n    /** @type {?Puppeteer.JSHandle} */\n    let success = null;\n    let error = null;\n    try {\n      success = await (await this._domWorld.executionContext()).evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n    } catch (e) {\n      error = e;\n    }\n\n    if (this._terminated || runCount !== this._runCount) {\n      if (success)\n        await success.dispose();\n      return;\n    }\n\n    // Ignore timeouts in pageScript - we track timeouts ourselves.\n    // If the frame's execution context has already changed, `frame.evaluate` will\n    // throw an error - ignore this predicate run altogether.\n    if (!error && await this._domWorld.evaluate(s => !s, success).catch(e => true)) {\n      await success.dispose();\n      return;\n    }\n\n    // When the page is navigated, the promise is rejected.\n    // We will try again in the new execution context.\n    if (error && error.message.includes('Execution context was destroyed'))\n      return;\n\n    // We could have tried to evaluate in a context which was already\n    // destroyed.\n    if (error && error.message.includes('Cannot find context with specified id'))\n      return;\n\n    if (error)\n      this._reject(error);\n    else\n      this._resolve(success);\n\n    this._cleanup();\n  }\n\n  _cleanup() {\n    clearTimeout(this._timeoutTimer);\n    this._domWorld._waitTasks.delete(this);\n    this._runningTask = null;\n  }\n}\n\n/**\n * @param {string} predicateBody\n * @param {string} polling\n * @param {number} timeout\n * @return {!Promise<*>}\n */\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n  const predicate = new Function('...args', predicateBody);\n  let timedOut = false;\n  if (timeout)\n    setTimeout(() => timedOut = true, timeout);\n  if (polling === 'raf')\n    return await pollRaf();\n  if (polling === 'mutation')\n    return await pollMutation();\n  if (typeof polling === 'number')\n    return await pollInterval(polling);\n\n  /**\n   * @return {!Promise<*>}\n   */\n  function pollMutation() {\n    const success = predicate.apply(null, args);\n    if (success)\n      return Promise.resolve(success);\n\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    const observer = new MutationObserver(mutations => {\n      if (timedOut) {\n        observer.disconnect();\n        fulfill();\n      }\n      const success = predicate.apply(null, args);\n      if (success) {\n        observer.disconnect();\n        fulfill(success);\n      }\n    });\n    observer.observe(document, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return result;\n  }\n\n  /**\n   * @return {!Promise<*>}\n   */\n  function pollRaf() {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onRaf();\n    return result;\n\n    function onRaf() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n      const success = predicate.apply(null, args);\n      if (success)\n        fulfill(success);\n      else\n        requestAnimationFrame(onRaf);\n    }\n  }\n\n  /**\n   * @param {number} pollInterval\n   * @return {!Promise<*>}\n   */\n  function pollInterval(pollInterval) {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    onTimeout();\n    return result;\n\n    function onTimeout() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n      const success = predicate.apply(null, args);\n      if (success)\n        fulfill(success);\n      else\n        setTimeout(onTimeout, pollInterval);\n    }\n  }\n}\n\nmodule.exports = {DOMWorld};\n"]},"metadata":{},"sourceType":"module"}