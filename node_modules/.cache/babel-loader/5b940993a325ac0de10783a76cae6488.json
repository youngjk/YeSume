{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {\n  TimeoutError\n} = require('./Errors');\n\nconst debugError = require('debug')(`puppeteer:error`);\n\nclass Helper {\n  /**\n   * @param {Function|string} fun\n   * @param {!Array<*>} args\n   * @return {string}\n   */\n  static evaluationString(fun, ...args) {\n    if (Helper.isString(fun)) {\n      assert(args.length === 0, 'Cannot evaluate a string with arguments');\n      return (\n        /** @type {string} */\n        fun\n      );\n    }\n\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n    /**\n     * @param {*} arg\n     * @return {string}\n     */\n\n    function serializeArgument(arg) {\n      if (Object.is(arg, undefined)) return 'undefined';\n      return JSON.stringify(arg);\n    }\n  }\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   * @return {string}\n   */\n\n\n  static getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception) return exceptionDetails.exception.description || exceptionDetails.exception.value;\n    let message = exceptionDetails.text;\n\n    if (exceptionDetails.stackTrace) {\n      for (const callframe of exceptionDetails.stackTrace.callFrames) {\n        const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n        const functionName = callframe.functionName || '<anonymous>';\n        message += `\\n    at ${functionName} (${location})`;\n      }\n    }\n\n    return message;\n  }\n  /**\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {*}\n   */\n\n\n  static valueFromRemoteObject(remoteObject) {\n    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n\n    if (remoteObject.unserializableValue) {\n      switch (remoteObject.unserializableValue) {\n        case '-0':\n          return -0;\n\n        case 'NaN':\n          return NaN;\n\n        case 'Infinity':\n          return Infinity;\n\n        case '-Infinity':\n          return -Infinity;\n\n        default:\n          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n      }\n    }\n\n    return remoteObject.value;\n  }\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n\n\n  static async releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId) return;\n    await client.send('Runtime.releaseObject', {\n      objectId: remoteObject.objectId\n    }).catch(error => {\n      // Exceptions might happen in case of a page been navigated or closed.\n      // Swallow these since they are harmless and we don't leak anything in this case.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {!Object} classType\n   */\n\n\n  static installAsyncStackHooks(classType) {\n    for (const methodName of Reflect.ownKeys(classType.prototype)) {\n      const method = Reflect.get(classType.prototype, methodName);\n      if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function' || method.constructor.name !== 'AsyncFunction') continue;\n      Reflect.set(classType.prototype, methodName, function (...args) {\n        const syncStack = new Error();\n        return method.call(this, ...args).catch(e => {\n          const stack = syncStack.stack.substring(syncStack.stack.indexOf('\\n') + 1);\n          const clientStack = stack.substring(stack.indexOf('\\n'));\n          if (e instanceof Error && e.stack && !e.stack.includes(clientStack)) e.stack += '\\n  -- ASYNC --\\n' + stack;\n          throw e;\n        });\n      });\n    }\n  }\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function(?):void} handler\n   * @return {{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?)}}\n   */\n\n\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return {\n      emitter,\n      eventName,\n      handler\n    };\n  }\n  /**\n   * @param {!Array<{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?):void}>} listeners\n   */\n\n\n  static removeEventListeners(listeners) {\n    for (const listener of listeners) listener.emitter.removeListener(listener.eventName, listener.handler);\n\n    listeners.splice(0, listeners.length);\n  }\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n\n\n  static isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n  }\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n\n\n  static isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n  }\n\n  static promisify(nodeFunction) {\n    function promisified(...args) {\n      return new Promise((resolve, reject) => {\n        function callback(err, ...result) {\n          if (err) return reject(err);\n          if (result.length === 1) return resolve(result[0]);\n          return resolve(result);\n        }\n\n        nodeFunction.call(null, ...args, callback);\n      });\n    }\n\n    return promisified;\n  }\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function} predicate\n   * @return {!Promise}\n   */\n\n\n  static waitForEvent(emitter, eventName, predicate, timeout) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    const listener = Helper.addEventListener(emitter, eventName, event => {\n      if (!predicate(event)) return;\n      cleanup();\n      resolveCallback(event);\n    });\n\n    if (timeout) {\n      eventTimeout = setTimeout(() => {\n        cleanup();\n        rejectCallback(new TimeoutError('Timeout exceeded while waiting for event'));\n      }, timeout);\n    }\n\n    function cleanup() {\n      Helper.removeEventListeners([listener]);\n      clearTimeout(eventTimeout);\n    }\n\n    return promise;\n  }\n  /**\n   * @template T\n   * @param {!Promise<T>} promise\n   * @param {string} taskName\n   * @param {number} timeout\n   * @return {!Promise<T>}\n   */\n\n\n  static async waitWithTimeout(promise, taskName, timeout) {\n    let reject;\n    const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n    const timeoutPromise = new Promise((resolve, x) => reject = x);\n    const timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n\n    try {\n      return await Promise.race([promise, timeoutPromise]);\n    } finally {\n      clearTimeout(timeoutTimer);\n    }\n  }\n\n}\n/**\n * @param {*} value\n * @param {string=} message\n */\n\n\nfunction assert(value, message) {\n  if (!value) throw new Error(message);\n}\n\nmodule.exports = {\n  helper: Helper,\n  assert,\n  debugError\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/node_modules/puppeteer/lib/helper.js"],"names":["TimeoutError","require","debugError","Helper","evaluationString","fun","args","isString","assert","length","map","serializeArgument","join","arg","Object","is","undefined","JSON","stringify","getExceptionMessage","exceptionDetails","exception","description","value","message","text","stackTrace","callframe","callFrames","location","url","lineNumber","columnNumber","functionName","valueFromRemoteObject","remoteObject","objectId","unserializableValue","NaN","Infinity","Error","releaseObject","client","send","catch","error","installAsyncStackHooks","classType","methodName","Reflect","ownKeys","prototype","method","get","startsWith","constructor","name","set","syncStack","call","e","stack","substring","indexOf","clientStack","includes","addEventListener","emitter","eventName","handler","on","removeEventListeners","listeners","listener","removeListener","splice","obj","String","isNumber","Number","promisify","nodeFunction","promisified","Promise","resolve","reject","callback","err","result","waitForEvent","predicate","timeout","eventTimeout","resolveCallback","rejectCallback","promise","event","cleanup","setTimeout","clearTimeout","waitWithTimeout","taskName","timeoutError","timeoutPromise","x","timeoutTimer","race","module","exports","helper"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {TimeoutError} = require('./Errors');\n\nconst debugError = require('debug')(`puppeteer:error`);\n\nclass Helper {\n  /**\n   * @param {Function|string} fun\n   * @param {!Array<*>} args\n   * @return {string}\n   */\n  static evaluationString(fun, ...args) {\n    if (Helper.isString(fun)) {\n      assert(args.length === 0, 'Cannot evaluate a string with arguments');\n      return /** @type {string} */ (fun);\n    }\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n\n    /**\n     * @param {*} arg\n     * @return {string}\n     */\n    function serializeArgument(arg) {\n      if (Object.is(arg, undefined))\n        return 'undefined';\n      return JSON.stringify(arg);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Runtime.ExceptionDetails} exceptionDetails\n   * @return {string}\n   */\n  static getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception)\n      return exceptionDetails.exception.description || exceptionDetails.exception.value;\n    let message = exceptionDetails.text;\n    if (exceptionDetails.stackTrace) {\n      for (const callframe of exceptionDetails.stackTrace.callFrames) {\n        const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n        const functionName = callframe.functionName || '<anonymous>';\n        message += `\\n    at ${functionName} (${location})`;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   * @return {*}\n   */\n  static valueFromRemoteObject(remoteObject) {\n    assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n    if (remoteObject.unserializableValue) {\n      switch (remoteObject.unserializableValue) {\n        case '-0':\n          return -0;\n        case 'NaN':\n          return NaN;\n        case 'Infinity':\n          return Infinity;\n        case '-Infinity':\n          return -Infinity;\n        default:\n          throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n      }\n    }\n    return remoteObject.value;\n  }\n\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Protocol.Runtime.RemoteObject} remoteObject\n   */\n  static async releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId)\n      return;\n    await client.send('Runtime.releaseObject', {objectId: remoteObject.objectId}).catch(error => {\n      // Exceptions might happen in case of a page been navigated or closed.\n      // Swallow these since they are harmless and we don't leak anything in this case.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!Object} classType\n   */\n  static installAsyncStackHooks(classType) {\n    for (const methodName of Reflect.ownKeys(classType.prototype)) {\n      const method = Reflect.get(classType.prototype, methodName);\n      if (methodName === 'constructor' || typeof methodName !== 'string' || methodName.startsWith('_') || typeof method !== 'function' || method.constructor.name !== 'AsyncFunction')\n        continue;\n      Reflect.set(classType.prototype, methodName, function(...args) {\n        const syncStack = new Error();\n        return method.call(this, ...args).catch(e => {\n          const stack = syncStack.stack.substring(syncStack.stack.indexOf('\\n') + 1);\n          const clientStack = stack.substring(stack.indexOf('\\n'));\n          if (e instanceof Error && e.stack && !e.stack.includes(clientStack))\n            e.stack += '\\n  -- ASYNC --\\n' + stack;\n          throw e;\n        });\n      });\n    }\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function(?):void} handler\n   * @return {{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?)}}\n   */\n  static addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return { emitter, eventName, handler };\n  }\n\n  /**\n   * @param {!Array<{emitter: !NodeJS.EventEmitter, eventName: (string|symbol), handler: function(?):void}>} listeners\n   */\n  static removeEventListeners(listeners) {\n    for (const listener of listeners)\n      listener.emitter.removeListener(listener.eventName, listener.handler);\n    listeners.splice(0, listeners.length);\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n  }\n\n  /**\n   * @param {!Object} obj\n   * @return {boolean}\n   */\n  static isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n  }\n\n  static promisify(nodeFunction) {\n    function promisified(...args) {\n      return new Promise((resolve, reject) => {\n        function callback(err, ...result) {\n          if (err)\n            return reject(err);\n          if (result.length === 1)\n            return resolve(result[0]);\n          return resolve(result);\n        }\n        nodeFunction.call(null, ...args, callback);\n      });\n    }\n    return promisified;\n  }\n\n  /**\n   * @param {!NodeJS.EventEmitter} emitter\n   * @param {(string|symbol)} eventName\n   * @param {function} predicate\n   * @return {!Promise}\n   */\n  static waitForEvent(emitter, eventName, predicate, timeout) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n      resolveCallback = resolve;\n      rejectCallback = reject;\n    });\n    const listener = Helper.addEventListener(emitter, eventName, event => {\n      if (!predicate(event))\n        return;\n      cleanup();\n      resolveCallback(event);\n    });\n    if (timeout) {\n      eventTimeout = setTimeout(() => {\n        cleanup();\n        rejectCallback(new TimeoutError('Timeout exceeded while waiting for event'));\n      }, timeout);\n    }\n    function cleanup() {\n      Helper.removeEventListeners([listener]);\n      clearTimeout(eventTimeout);\n    }\n    return promise;\n  }\n\n  /**\n   * @template T\n   * @param {!Promise<T>} promise\n   * @param {string} taskName\n   * @param {number} timeout\n   * @return {!Promise<T>}\n   */\n  static async waitWithTimeout(promise, taskName, timeout) {\n    let reject;\n    const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n    const timeoutPromise = new Promise((resolve, x) => reject = x);\n    const timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n    try {\n      return await Promise.race([promise, timeoutPromise]);\n    } finally {\n      clearTimeout(timeoutTimer);\n    }\n  }\n}\n\n/**\n * @param {*} value\n * @param {string=} message\n */\nfunction assert(value, message) {\n  if (!value)\n    throw new Error(message);\n}\n\nmodule.exports = {\n  helper: Helper,\n  assert,\n  debugError\n};\n"]},"metadata":{},"sourceType":"script"}