{"ast":null,"code":"'use strict';\n\nvar format = require('./format');\n/*\n * function cascade(formats)\n * Returns a function that invokes the `._format` function in-order\n * for the specified set of `formats`. In this manner we say that Formats\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\n */\n\n\nfunction cascade(formats) {\n  if (!formats.every(isValidFormat)) {\n    return;\n  }\n\n  return function (info) {\n    var obj = info;\n\n    for (var i = 0; i < formats.length; i++) {\n      obj = formats[i].transform(obj, formats[i].options);\n\n      if (!obj) {\n        return false;\n      }\n    }\n\n    return obj;\n  };\n}\n/*\n * function isValidFormat(format)\n * If the format does not define a `transform` function throw an error\n * with more detailed usage.\n */\n\n\nfunction isValidFormat(fmt) {\n  if (typeof fmt.transform !== 'function') {\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\n  }\n\n  return true;\n}\n/*\n * function combine (info)\n * Returns a new instance of the combine Format which combines the specified\n * formats into a new format. This is similar to a pipe-chain in transform streams.\n * We choose to combine the prototypes this way because there is no back pressure in\n * an in-memory transform chain.\n */\n\n\nmodule.exports = function () {\n  for (var _len = arguments.length, formats = Array(_len), _key = 0; _key < _len; _key++) {\n    formats[_key] = arguments[_key];\n  }\n\n  var combinedFormat = format(cascade(formats));\n  var instance = combinedFormat();\n  instance.Format = combinedFormat.Format;\n  return instance;\n}; //\n// Export the cascade method for use in cli and other\n// combined formats that should not be assumed to be\n// singletons.\n//\n\n\nmodule.exports.cascade = cascade;","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/node_modules/logform/dist/combine.js"],"names":["format","require","cascade","formats","every","isValidFormat","info","obj","i","length","transform","options","fmt","Error","join","module","exports","_len","arguments","Array","_key","combinedFormat","instance","Format"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,OAAT,CAAiBC,OAAjB,EAA0B;AACxB,MAAI,CAACA,OAAO,CAACC,KAAR,CAAcC,aAAd,CAAL,EAAmC;AACjC;AACD;;AAED,SAAO,UAAUC,IAAV,EAAgB;AACrB,QAAIC,GAAG,GAAGD,IAAV;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACM,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvCD,MAAAA,GAAG,GAAGJ,OAAO,CAACK,CAAD,CAAP,CAAWE,SAAX,CAAqBH,GAArB,EAA0BJ,OAAO,CAACK,CAAD,CAAP,CAAWG,OAArC,CAAN;;AACA,UAAI,CAACJ,GAAL,EAAU;AACR,eAAO,KAAP;AACD;AACF;;AAED,WAAOA,GAAP;AACD,GAVD;AAWD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASF,aAAT,CAAuBO,GAAvB,EAA4B;AAC1B,MAAI,OAAOA,GAAG,CAACF,SAAX,KAAyB,UAA7B,EAAyC;AACvC,UAAM,IAAIG,KAAJ,CAAU,CAAC,0EAAD,EAA6E,oCAA7E,EAAmH,8BAAnH,EAAmJC,IAAnJ,CAAwJ,IAAxJ,CAAV,CAAN;AACD;;AAED,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,YAAY;AAC3B,OAAK,IAAIC,IAAI,GAAGC,SAAS,CAACT,MAArB,EAA6BN,OAAO,GAAGgB,KAAK,CAACF,IAAD,CAA5C,EAAoDG,IAAI,GAAG,CAAhE,EAAmEA,IAAI,GAAGH,IAA1E,EAAgFG,IAAI,EAApF,EAAwF;AACtFjB,IAAAA,OAAO,CAACiB,IAAD,CAAP,GAAgBF,SAAS,CAACE,IAAD,CAAzB;AACD;;AAED,MAAIC,cAAc,GAAGrB,MAAM,CAACE,OAAO,CAACC,OAAD,CAAR,CAA3B;AACA,MAAImB,QAAQ,GAAGD,cAAc,EAA7B;AACAC,EAAAA,QAAQ,CAACC,MAAT,GAAkBF,cAAc,CAACE,MAAjC;AACA,SAAOD,QAAP;AACD,CATD,C,CAWA;AACA;AACA;AACA;AACA;;;AACAP,MAAM,CAACC,OAAP,CAAed,OAAf,GAAyBA,OAAzB","sourcesContent":["'use strict';\n\nvar format = require('./format');\n\n/*\n * function cascade(formats)\n * Returns a function that invokes the `._format` function in-order\n * for the specified set of `formats`. In this manner we say that Formats\n * are \"pipe-like\", but not a pure pumpify implementation. Since there is no back\n * pressure we can remove all of the \"readable\" plumbing in Node streams.\n */\nfunction cascade(formats) {\n  if (!formats.every(isValidFormat)) {\n    return;\n  }\n\n  return function (info) {\n    var obj = info;\n    for (var i = 0; i < formats.length; i++) {\n      obj = formats[i].transform(obj, formats[i].options);\n      if (!obj) {\n        return false;\n      }\n    }\n\n    return obj;\n  };\n}\n\n/*\n * function isValidFormat(format)\n * If the format does not define a `transform` function throw an error\n * with more detailed usage.\n */\nfunction isValidFormat(fmt) {\n  if (typeof fmt.transform !== 'function') {\n    throw new Error(['No transform function found on format. Did you create a format instance?', 'const myFormat = format(formatFn);', 'const instance = myFormat();'].join('\\n'));\n  }\n\n  return true;\n}\n\n/*\n * function combine (info)\n * Returns a new instance of the combine Format which combines the specified\n * formats into a new format. This is similar to a pipe-chain in transform streams.\n * We choose to combine the prototypes this way because there is no back pressure in\n * an in-memory transform chain.\n */\nmodule.exports = function () {\n  for (var _len = arguments.length, formats = Array(_len), _key = 0; _key < _len; _key++) {\n    formats[_key] = arguments[_key];\n  }\n\n  var combinedFormat = format(cascade(formats));\n  var instance = combinedFormat();\n  instance.Format = combinedFormat.Format;\n  return instance;\n};\n\n//\n// Export the cascade method for use in cli and other\n// combined formats that should not be assumed to be\n// singletons.\n//\nmodule.exports.cascade = cascade;"]},"metadata":{},"sourceType":"script"}