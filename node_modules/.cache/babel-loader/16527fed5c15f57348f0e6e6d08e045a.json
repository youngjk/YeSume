{"ast":null,"code":"/* eslint no-unused-vars: 0 */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar _require = require('triple-beam'),\n    configs = _require.configs,\n    LEVEL = _require.LEVEL,\n    MESSAGE = _require.MESSAGE;\n\nvar Padder = function () {\n  function Padder() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      levels: configs.npm.levels\n    };\n\n    _classCallCheck(this, Padder);\n\n    this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);\n    this.options = opts;\n  }\n  /**\n   * Returns the maximum length of keys in the specified `levels` Object.\n   * @param  {Object} levels Set of all levels to calculate longest level against.\n   * @returns {Number} Maximum length of the longest level string.\n   */\n\n\n  _createClass(Padder, [{\n    key: 'transform',\n\n    /**\n     * Prepends the padding onto the `message` based on the `LEVEL` of\n     * the `info`. This is based on the behavior of `winston@2` which also\n     * prepended the level onto the message.\n     *\n     * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201\n     *\n     * @param  {Info} info Logform info object\n     * @param  {Object} opts Options passed along to this instance.\n     * @returns {Info} Modified logform info object.\n     */\n    value: function transform(info, opts) {\n      info.message = '' + this.paddings[info[LEVEL]] + info.message;\n\n      if (info[MESSAGE]) {\n        info[MESSAGE] = '' + this.paddings[info[LEVEL]] + info[MESSAGE];\n      }\n\n      return info;\n    }\n  }], [{\n    key: 'getLongestLevel',\n    value: function getLongestLevel(levels) {\n      var lvls = Object.keys(levels).map(function (level) {\n        return level.length;\n      });\n      return Math.max.apply(Math, _toConsumableArray(lvls));\n    }\n    /**\n     * Returns the padding for the specified `level` assuming that the\n     * maximum length of all levels it's associated with is `maxLength`.\n     * @param  {String} level Level to calculate padding for.\n     * @param  {String} filler Repeatable text to use for padding.\n     * @param  {Number} maxLength Length of the longest level\n     * @returns {String} Padding string for the `level`\n     */\n\n  }, {\n    key: 'paddingForLevel',\n    value: function paddingForLevel(level, filler, maxLength) {\n      var targetLen = maxLength + 1 - level.length;\n      var rep = Math.floor(targetLen / filler.length);\n      var padding = '' + filler + filler.repeat(rep);\n      return padding.slice(0, targetLen);\n    }\n    /**\n     * Returns an object with the string paddings for the given `levels`\n     * using the specified `filler`.\n     * @param  {Object} levels Set of all levels to calculate padding for.\n     * @param  {String} filler Repeatable text to use for padding.\n     * @returns {Object} Mapping of level to desired padding.\n     */\n\n  }, {\n    key: 'paddingForLevels',\n    value: function paddingForLevels(levels) {\n      var filler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n      var maxLength = Padder.getLongestLevel(levels);\n      return Object.keys(levels).reduce(function (acc, level) {\n        acc[level] = Padder.paddingForLevel(level, filler, maxLength);\n        return acc;\n      }, {});\n    }\n  }]);\n\n  return Padder;\n}();\n/*\n * function padLevels (info)\n * Returns a new instance of the padLevels Format which pads\n * levels to be the same length. This was previously exposed as\n * { padLevels: true } to transports in `winston < 3.0.0`.\n */\n\n\nmodule.exports = function (opts) {\n  return new Padder(opts);\n};\n\nmodule.exports.Padder = module.exports.Format = Padder;","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/node_modules/logform/dist/pad-levels.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","TypeError","_require","require","configs","LEVEL","MESSAGE","Padder","opts","arguments","undefined","levels","npm","paddings","paddingForLevels","filler","options","value","transform","info","message","getLongestLevel","lvls","keys","map","level","Math","max","apply","paddingForLevel","maxLength","targetLen","rep","floor","padding","repeat","slice","reduce","acc","module","exports","Format"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: 0 */\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require('triple-beam'),\n    configs = _require.configs,\n    LEVEL = _require.LEVEL,\n    MESSAGE = _require.MESSAGE;\n\nvar Padder = function () {\n  function Padder() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { levels: configs.npm.levels };\n\n    _classCallCheck(this, Padder);\n\n    this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);\n    this.options = opts;\n  }\n\n  /**\n   * Returns the maximum length of keys in the specified `levels` Object.\n   * @param  {Object} levels Set of all levels to calculate longest level against.\n   * @returns {Number} Maximum length of the longest level string.\n   */\n\n\n  _createClass(Padder, [{\n    key: 'transform',\n\n\n    /**\n     * Prepends the padding onto the `message` based on the `LEVEL` of\n     * the `info`. This is based on the behavior of `winston@2` which also\n     * prepended the level onto the message.\n     *\n     * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201\n     *\n     * @param  {Info} info Logform info object\n     * @param  {Object} opts Options passed along to this instance.\n     * @returns {Info} Modified logform info object.\n     */\n    value: function transform(info, opts) {\n      info.message = '' + this.paddings[info[LEVEL]] + info.message;\n      if (info[MESSAGE]) {\n        info[MESSAGE] = '' + this.paddings[info[LEVEL]] + info[MESSAGE];\n      }\n\n      return info;\n    }\n  }], [{\n    key: 'getLongestLevel',\n    value: function getLongestLevel(levels) {\n      var lvls = Object.keys(levels).map(function (level) {\n        return level.length;\n      });\n      return Math.max.apply(Math, _toConsumableArray(lvls));\n    }\n\n    /**\n     * Returns the padding for the specified `level` assuming that the\n     * maximum length of all levels it's associated with is `maxLength`.\n     * @param  {String} level Level to calculate padding for.\n     * @param  {String} filler Repeatable text to use for padding.\n     * @param  {Number} maxLength Length of the longest level\n     * @returns {String} Padding string for the `level`\n     */\n\n  }, {\n    key: 'paddingForLevel',\n    value: function paddingForLevel(level, filler, maxLength) {\n      var targetLen = maxLength + 1 - level.length;\n      var rep = Math.floor(targetLen / filler.length);\n      var padding = '' + filler + filler.repeat(rep);\n      return padding.slice(0, targetLen);\n    }\n\n    /**\n     * Returns an object with the string paddings for the given `levels`\n     * using the specified `filler`.\n     * @param  {Object} levels Set of all levels to calculate padding for.\n     * @param  {String} filler Repeatable text to use for padding.\n     * @returns {Object} Mapping of level to desired padding.\n     */\n\n  }, {\n    key: 'paddingForLevels',\n    value: function paddingForLevels(levels) {\n      var filler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n\n      var maxLength = Padder.getLongestLevel(levels);\n      return Object.keys(levels).reduce(function (acc, level) {\n        acc[level] = Padder.paddingForLevel(level, filler, maxLength);\n        return acc;\n      }, {});\n    }\n  }]);\n\n  return Padder;\n}();\n\n/*\n * function padLevels (info)\n * Returns a new instance of the padLevels Format which pads\n * levels to be the same length. This was previously exposed as\n * { padLevels: true } to transports in `winston < 3.0.0`.\n */\n\n\nmodule.exports = function (opts) {\n  return new Padder(opts);\n};\n\nmodule.exports.Padder = module.exports.Format = Padder;"]},"metadata":{},"sourceType":"script"}