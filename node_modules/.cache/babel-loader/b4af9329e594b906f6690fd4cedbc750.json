{"ast":null,"code":"/**\n * tail-file.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n'use strict';\n\nconst fs = require('fs');\n\nconst {\n  StringDecoder\n} = require('string_decoder');\n\nconst {\n  Stream\n} = require('readable-stream');\n/**\n * Simple no-op function.\n * @returns {undefined}\n */\n\n\nfunction noop() {}\n/**\n * TODO: add function description.\n * @param {Object} options - Options for tail.\n * @param {function} iter - Iterator function to execute on every line.\n* `tail -f` a file. Options must include file.\n * @returns {mixed} - TODO: add return description.\n */\n\n\nmodule.exports = (options, iter) => {\n  const buffer = Buffer.alloc(64 * 1024);\n  const decode = new StringDecoder('utf8');\n  const stream = new Stream();\n  let buff = '';\n  let pos = 0;\n  let row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n\n  stream.destroy = () => {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', (err, fd) => {\n    if (err) {\n      if (!iter) {\n        stream.emit('error', err);\n      } else {\n        iter(err);\n      }\n\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd, noop);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, (err, bytes) => {\n        if (err) {\n          if (!iter) {\n            stream.emit('error', err);\n          } else {\n            iter(err);\n          }\n\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            // eslint-disable-next-line eqeqeq\n            if (options.start == null || row > options.start) {\n              if (!iter) {\n                stream.emit('line', buff);\n              } else {\n                iter(null, buff);\n              }\n            }\n\n            row++;\n            buff = '';\n          }\n\n          return setTimeout(read, 1000);\n        }\n\n        let data = decode.write(buffer.slice(0, bytes));\n\n        if (!iter) {\n          stream.emit('data', data);\n        }\n\n        data = (buff + data).split(/\\n+/);\n        const l = data.length - 1;\n        let i = 0;\n\n        for (; i < l; i++) {\n          // eslint-disable-next-line eqeqeq\n          if (options.start == null || row > options.start) {\n            if (!iter) {\n              stream.emit('line', data[i]);\n            } else {\n              iter(null, data[i]);\n            }\n          }\n\n          row++;\n        }\n\n        buff = data[l];\n        pos += bytes;\n        return read();\n      });\n    })();\n  });\n\n  if (!iter) {\n    return stream;\n  }\n\n  return stream.destroy;\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/winston/lib/winston/tail-file.js"],"names":["fs","require","StringDecoder","Stream","noop","module","exports","options","iter","buffer","Buffer","alloc","decode","stream","buff","pos","row","start","readable","destroy","destroyed","emit","open","file","err","fd","read","close","length","bytes","setTimeout","data","write","slice","split","l","i"],"mappings":"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","sourcesContent":["/**\n * tail-file.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst { StringDecoder } = require('string_decoder');\nconst { Stream } = require('readable-stream');\n\n/**\n * Simple no-op function.\n * @returns {undefined}\n */\nfunction noop() {}\n\n/**\n * TODO: add function description.\n * @param {Object} options - Options for tail.\n * @param {function} iter - Iterator function to execute on every line.\n* `tail -f` a file. Options must include file.\n * @returns {mixed} - TODO: add return description.\n */\nmodule.exports = (options, iter) => {\n  const buffer = Buffer.alloc(64 * 1024);\n  const decode = new StringDecoder('utf8');\n  const stream = new Stream();\n  let buff = '';\n  let pos = 0;\n  let row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n  stream.destroy = () => {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', (err, fd) => {\n    if (err) {\n      if (!iter) {\n        stream.emit('error', err);\n      } else {\n        iter(err);\n      }\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd, noop);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, (err, bytes) => {\n        if (err) {\n          if (!iter) {\n            stream.emit('error', err);\n          } else {\n            iter(err);\n          }\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            // eslint-disable-next-line eqeqeq\n            if (options.start == null || row > options.start) {\n              if (!iter) {\n                stream.emit('line', buff);\n              } else {\n                iter(null, buff);\n              }\n            }\n            row++;\n            buff = '';\n          }\n          return setTimeout(read, 1000);\n        }\n\n        let data = decode.write(buffer.slice(0, bytes));\n        if (!iter) {\n          stream.emit('data', data);\n        }\n\n        data = (buff + data).split(/\\n+/);\n\n        const l = data.length - 1;\n        let i = 0;\n\n        for (; i < l; i++) {\n          // eslint-disable-next-line eqeqeq\n          if (options.start == null || row > options.start) {\n            if (!iter) {\n              stream.emit('line', data[i]);\n            } else {\n              iter(null, data[i]);\n            }\n          }\n          row++;\n        }\n\n        buff = data[l];\n        pos += bytes;\n        return read();\n      });\n    }());\n  });\n\n  if (!iter) {\n    return stream;\n  }\n\n  return stream.destroy;\n};\n"]},"metadata":{},"sourceType":"module"}