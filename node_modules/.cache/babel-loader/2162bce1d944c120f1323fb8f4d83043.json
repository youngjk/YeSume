{"ast":null,"code":"/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst asyncSeries = require('async/series');\n\nconst zlib = require('zlib');\n\nconst {\n  MESSAGE\n} = require('triple-beam');\n\nconst {\n  Stream,\n  PassThrough\n} = require('readable-stream');\n\nconst TransportStream = require('winston-transport');\n\nconst debug = require('diagnostics')('winston:file');\n\nconst os = require('os');\n\nconst tailFile = require('../tail-file');\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\n\n\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options); // Expose the name of this Transport on the prototype.\n\n    this.name = options.name || 'file'; // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    } // Setup the base stream that always gets piped to to handle buffering.\n\n\n    this._stream = new PassThrough();\n\n    this._stream.setMaxListeners(30); // Bind this context for listener methods.\n\n\n    this._onError = this._onError.bind(this);\n\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename ? path.basename(options.filename) : 'winston.log';\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || {\n        flags: 'a'\n      };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream)); // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = options.eol || os.EOL;\n    this.tailable = options.tailable || false; // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n    this.open();\n  }\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  log(info, callback = () => {}) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    } // Output stream buffer is full and has asked us to wait for the drain event\n\n\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n\n      return;\n    } // Grab the raw string and append the expected EOL.\n\n\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output); // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info); // Do not attempt to rotate files while opening\n\n      if (this._opening) {\n        return;\n      } // Check to see if we need to end the stream and create a new one.\n\n\n      if (!this._needsNewFile()) {\n        return;\n      } // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n\n\n      this._endStream(() => this._rotateFile());\n    } // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n\n\n    this._pendingSize += bytes;\n\n    if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n\n    const written = this._stream.write(output, logged.bind(this));\n\n    if (!written) {\n      this._drain = true;\n\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n\n    debug('written', written, this._drain);\n    return written;\n  }\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n\n\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = this.normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n\n      if (!callback) {\n        return;\n      }\n\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n\n        row++;\n      }\n\n      buff = data[l];\n    });\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n\n      if (options.order === 'desc') {\n        results = results.reverse();\n      } // eslint-disable-next-line callback-return\n\n\n      if (callback) callback(null, results);\n    });\n\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (options.rows && results.length >= options.rows && options.order !== 'desc') {\n        if (stream.readable) {\n          stream.destroy();\n        }\n\n        return;\n      }\n\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      const time = new Date(log.timestamp);\n\n      if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {\n        return;\n      }\n\n      return true;\n    }\n  }\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n\n\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n    return stream;\n  }\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n\n\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n    this._opening = true; // Stat the target file to get the size and create the stream.\n\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n    });\n  }\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  stat(callback) {\n    const target = this._getFile();\n\n    const fullpath = path.join(this.dirname, target);\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENT ok', fullpath); // Update internally tracked filename with the new target name.\n\n        this.filename = target;\n        return callback(null, 0);\n      }\n\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      } // Once we have figured out what the filename is, set it\n      // and return the size.\n\n\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  _onError(err) {\n    this.emit('error', err);\n  }\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n    return stream;\n  }\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n\n\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n    return stream;\n  }\n  /**\n   * TODO: add method description.\n   */\n\n\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n\n\n  _endStream(callback) {\n    this._stream.unpipe(this._dest);\n\n    this._dest.end(() => {\n      this._cleanupStream(this._dest);\n\n      callback();\n    });\n  }\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source – PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n\n\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options) // TODO: What should we do with errors here?\n    .on('error', err => debug(err)).on('close', () => debug('close', dest.path, dest.bytesWritten)).on('open', () => {\n      debug('file open ok', fullpath);\n      this.emit('open', fullpath);\n      source.pipe(dest); // If rotation occured during the open operation then we immediately\n      // start writing to a new PassThrough, begin opening the next file\n      // and cleanup the previous source and dest once the source has drained.\n\n      if (this.rotatedWhileOpening) {\n        this._stream = new PassThrough();\n\n        this._stream.setMaxListeners(30);\n\n        this._rotateFile();\n\n        this.rotatedWhileOpening = false;\n\n        this._cleanupStream(dest);\n\n        source.end();\n      }\n    });\n    debug('create stream ok', fullpath);\n\n    if (this.zippedArchive) {\n      const gzip = zlib.createGzip();\n      gzip.pipe(dest);\n      return gzip;\n    }\n\n    return dest;\n  }\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n\n\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n\n    if (!this.tailable) {\n      this._created += 1;\n\n      this._checkMaxFilesIncrementing(ext, basename, callback);\n    } else {\n      this._checkMaxFilesTailable(ext, basename, callback);\n    }\n  }\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n\n\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat ? this.rotationFormat() : this._created; // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n\n    const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;\n    return this.zippedArchive ? `${target}.gz` : target;\n  }\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n    fs.unlink(target, callback);\n  }\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n\n    if (!this.maxFiles) {\n      return;\n    } // const isZipped = this.zippedArchive ? '.gz' : '';\n\n\n    const isZipped = this.zippedArchive ? '.gz' : '';\n\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${i - 1}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n\n    asyncSeries(tasks, () => {\n      fs.rename(path.join(this.dirname, `${basename}${ext}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/node_modules/winston/lib/winston/transports/file.js"],"names":["fs","require","path","asyncSeries","zlib","MESSAGE","Stream","PassThrough","TransportStream","debug","os","tailFile","module","exports","File","constructor","options","name","throwIf","target","args","slice","forEach","Error","_stream","setMaxListeners","_onError","bind","filename","dirname","_basename","basename","flags","stream","console","warn","_dest","pipe","_setupStream","maxsize","rotationFormat","zippedArchive","maxFiles","eol","EOL","tailable","_size","_pendingSize","_created","_drain","_opening","open","log","info","callback","silent","once","output","bytes","Buffer","byteLength","logged","emit","_needsNewFile","_endStream","_rotateFile","rotatedWhileOpening","written","write","query","normalizeQuery","file","join","buff","results","row","createReadStream","encoding","on","err","readable","destroy","code","data","split","l","length","i","start","add","order","reverse","attempt","JSON","parse","check","push","e","rows","fields","reduce","obj","key","shift","time","Date","timestamp","from","until","level","tail","line","stat","size","_createStream","_getFile","fullpath","_incFile","close","cb","end","_cleanupStream","removeListener","unpipe","source","dest","createWriteStream","bytesWritten","gzip","createGzip","ext","extname","_checkMaxFilesIncrementing","_checkMaxFilesTailable","isRotation","setImmediate","oldest","isOldest","isZipped","filePath","unlink","tasks","x","fileName","tmppath","exists","rename"],"mappings":"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","sourcesContent":["/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst asyncSeries = require('async/series');\nconst zlib = require('zlib');\nconst { MESSAGE } = require('triple-beam');\nconst { Stream, PassThrough } = require('readable-stream');\nconst TransportStream = require('winston-transport');\nconst debug = require('diagnostics')('winston:file');\nconst os = require('os');\nconst tailFile = require('../tail-file');\n\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype.\n    this.name = options.name || 'file';\n\n    // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    }\n\n    // Setup the base stream that always gets piped to to handle buffering.\n    this._stream = new PassThrough();\n    this._stream.setMaxListeners(30);\n\n    // Bind this context for listener methods.\n    this._onError = this._onError.bind(this);\n\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename\n        ? path.basename(options.filename)\n        : 'winston.log';\n\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || { flags: 'a' };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream));\n      // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = options.eol || os.EOL;\n    this.tailable = options.tailable || false;\n\n    // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n\n    this.open();\n  }\n\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback = () => {}) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    }\n\n    // Output stream buffer is full and has asked us to wait for the drain event\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n\n    // Grab the raw string and append the expected EOL.\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output);\n\n    // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info);\n\n      // Do not attempt to rotate files while opening\n      if (this._opening) {\n        return;\n      }\n\n      // Check to see if we need to end the stream and create a new one.\n      if (!this._needsNewFile()) {\n        return;\n      }\n\n      // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n      this._endStream(() => this._rotateFile());\n    }\n\n    // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n    this._pendingSize += bytes;\n    if (this._opening\n      && !this.rotatedWhileOpening\n      && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n\n    const written = this._stream.write(output, logged.bind(this));\n    if (!written) {\n      this._drain = true;\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n\n    debug('written', written, this._drain);\n\n    return written;\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = this.normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n\n      buff = data[l];\n    });\n\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      // eslint-disable-next-line callback-return\n      if (callback) callback(null, results);\n    });\n\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (\n        options.rows &&\n        results.length >= options.rows &&\n        options.order !== 'desc'\n      ) {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      const time = new Date(log.timestamp);\n      if (\n        (options.from && time < options.from) ||\n        (options.until && time > options.until) ||\n        (options.level && options.level !== log.level)\n      ) {\n        return;\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n\n    return stream;\n  }\n\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n\n    this._opening = true;\n\n    // Stat the target file to get the size and create the stream.\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n    });\n  }\n\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  stat(callback) {\n    const target = this._getFile();\n    const fullpath = path.join(this.dirname, target);\n\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENT ok', fullpath);\n        // Update internally tracked filename with the new target name.\n        this.filename = target;\n        return callback(null, 0);\n      }\n\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      }\n\n      // Once we have figured out what the filename is, set it\n      // and return the size.\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   */\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n  _endStream(callback) {\n    this._stream.unpipe(this._dest);\n    this._dest.end(() => {\n      this._cleanupStream(this._dest);\n      callback();\n    });\n  }\n\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source – PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options)\n      // TODO: What should we do with errors here?\n      .on('error', err => debug(err))\n      .on('close', () => debug('close', dest.path, dest.bytesWritten))\n      .on('open', () => {\n        debug('file open ok', fullpath);\n        this.emit('open', fullpath);\n        source.pipe(dest);\n\n        // If rotation occured during the open operation then we immediately\n        // start writing to a new PassThrough, begin opening the next file\n        // and cleanup the previous source and dest once the source has drained.\n        if (this.rotatedWhileOpening) {\n          this._stream = new PassThrough();\n          this._stream.setMaxListeners(30);\n          this._rotateFile();\n          this.rotatedWhileOpening = false;\n          this._cleanupStream(dest);\n          source.end();\n        }\n      });\n\n    debug('create stream ok', fullpath);\n    if (this.zippedArchive) {\n      const gzip = zlib.createGzip();\n      gzip.pipe(dest);\n      return gzip;\n    }\n\n    return dest;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n\n    if (!this.tailable) {\n      this._created += 1;\n      this._checkMaxFilesIncrementing(ext, basename, callback);\n    } else {\n      this._checkMaxFilesTailable(ext, basename, callback);\n    }\n  }\n\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat\n      ? this.rotationFormat()\n      : this._created;\n\n    // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n    const target = !this.tailable && this._created\n      ? `${basename}${isRotation}${ext}`\n      : `${basename}${ext}`;\n\n    return this.zippedArchive\n      ? `${target}.gz`\n      : target;\n  }\n\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n\n    fs.unlink(target, callback);\n  }\n\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n    if (!this.maxFiles) {\n      return;\n    }\n\n    // const isZipped = this.zippedArchive ? '.gz' : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n\n    asyncSeries(tasks, () => {\n      fs.rename(\n        path.join(this.dirname, `${basename}${ext}`),\n        path.join(this.dirname, `${basename}1${ext}${isZipped}`),\n        callback\n      );\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}