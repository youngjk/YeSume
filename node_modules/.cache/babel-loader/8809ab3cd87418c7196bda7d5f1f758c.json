{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {\n  assert\n} = require('./helper');\n\nconst {\n  Events\n} = require('./Events');\n\nconst debugProtocol = require('debug')('puppeteer:protocol');\n\nconst EventEmitter = require('events');\n\nclass Connection extends EventEmitter {\n  /**\n   * @param {string} url\n   * @param {!Puppeteer.ConnectionTransport} transport\n   * @param {number=} delay\n   */\n  constructor(url, transport, delay = 0) {\n    super();\n    this._url = url;\n    this._lastId = 0;\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n\n    this._callbacks = new Map();\n    this._delay = delay;\n    this._transport = transport;\n    this._transport.onmessage = this._onMessage.bind(this);\n    this._transport.onclose = this._onClose.bind(this);\n    /** @type {!Map<string, !CDPSession>}*/\n\n    this._sessions = new Map();\n    this._closed = false;\n  }\n  /**\n   * @param {!CDPSession} session\n   * @return {!Connection}\n   */\n\n\n  static fromSession(session) {\n    return session._connection;\n  }\n  /**\n   * @param {string} sessionId\n   * @return {?CDPSession}\n   */\n\n\n  session(sessionId) {\n    return this._sessions.get(sessionId) || null;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n\n\n  send(method, params = {}) {\n    const id = this._rawSend({\n      method,\n      params\n    });\n\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new Error(),\n        method\n      });\n    });\n  }\n  /**\n   * @param {*} message\n   * @return {number}\n   */\n\n\n  _rawSend(message) {\n    const id = ++this._lastId;\n    message = JSON.stringify(Object.assign({}, message, {\n      id\n    }));\n    debugProtocol('SEND ► ' + message);\n\n    this._transport.send(message);\n\n    return id;\n  }\n  /**\n   * @param {string} message\n   */\n\n\n  async _onMessage(message) {\n    if (this._delay) await new Promise(f => setTimeout(f, this._delay));\n    debugProtocol('◀ RECV ' + message);\n    const object = JSON.parse(message);\n\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSession(this, object.params.targetInfo.type, sessionId);\n\n      this._sessions.set(sessionId, session);\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this._sessions.get(object.params.sessionId);\n\n      if (session) {\n        session._onClosed();\n\n        this._sessions.delete(object.params.sessionId);\n      }\n    }\n\n    if (object.sessionId) {\n      const session = this._sessions.get(object.sessionId);\n\n      if (session) session._onMessage(object);\n    } else if (object.id) {\n      const callback = this._callbacks.get(object.id); // Callbacks could be all rejected if someone has called `.dispose()`.\n\n\n      if (callback) {\n        this._callbacks.delete(object.id);\n\n        if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object));else callback.resolve(object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n\n  _onClose() {\n    if (this._closed) return;\n    this._closed = true;\n    this._transport.onmessage = null;\n    this._transport.onclose = null;\n\n    for (const callback of this._callbacks.values()) callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n\n    this._callbacks.clear();\n\n    for (const session of this._sessions.values()) session._onClosed();\n\n    this._sessions.clear();\n\n    this.emit(Events.Connection.Disconnected);\n  }\n\n  dispose() {\n    this._onClose();\n\n    this._transport.close();\n  }\n  /**\n   * @param {Protocol.Target.TargetInfo} targetInfo\n   * @return {!Promise<!CDPSession>}\n   */\n\n\n  async createSession(targetInfo) {\n    const {\n      sessionId\n    } = await this.send('Target.attachToTarget', {\n      targetId: targetInfo.targetId,\n      flatten: true\n    });\n    return this._sessions.get(sessionId);\n  }\n\n}\n\nclass CDPSession extends EventEmitter {\n  /**\n   * @param {!Connection} connection\n   * @param {string} targetType\n   * @param {string} sessionId\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n\n    this._callbacks = new Map();\n    this._connection = connection;\n    this._targetType = targetType;\n    this._sessionId = sessionId;\n  }\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n\n\n  send(method, params = {}) {\n    if (!this._connection) return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));\n\n    const id = this._connection._rawSend({\n      sessionId: this._sessionId,\n      method,\n      params\n    });\n\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {\n        resolve,\n        reject,\n        error: new Error(),\n        method\n      });\n    });\n  }\n  /**\n   * @param {{id?: number, method: string, params: Object, error: {message: string, data: any}, result?: *}} object\n   */\n\n\n  _onMessage(object) {\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n\n      this._callbacks.delete(object.id);\n\n      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object));else callback.resolve(object.result);\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n\n  async detach() {\n    if (!this._connection) throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);\n    await this._connection.send('Target.detachFromTarget', {\n      sessionId: this._sessionId\n    });\n  }\n\n  _onClosed() {\n    for (const callback of this._callbacks.values()) callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n\n    this._callbacks.clear();\n\n    this._connection = null;\n    this.emit(Events.CDPSession.Disconnected);\n  }\n\n}\n/**\n * @param {!Error} error\n * @param {string} method\n * @param {{error: {message: string, data: any}}} object\n * @return {!Error}\n */\n\n\nfunction createProtocolError(error, method, object) {\n  let message = `Protocol error (${method}): ${object.error.message}`;\n  if ('data' in object.error) message += ` ${object.error.data}`;\n  return rewriteError(error, message);\n}\n/**\n * @param {!Error} error\n * @param {string} message\n * @return {!Error}\n */\n\n\nfunction rewriteError(error, message) {\n  error.message = message;\n  return error;\n}\n\nmodule.exports = {\n  Connection,\n  CDPSession\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/puppeteer/lib/Connection.js"],"names":["assert","require","Events","debugProtocol","EventEmitter","Connection","constructor","url","transport","delay","_url","_lastId","_callbacks","Map","_delay","_transport","onmessage","_onMessage","bind","onclose","_onClose","_sessions","_closed","fromSession","session","_connection","sessionId","get","send","method","params","id","_rawSend","Promise","resolve","reject","set","error","Error","message","JSON","stringify","Object","assign","f","setTimeout","object","parse","CDPSession","targetInfo","type","_onClosed","delete","callback","createProtocolError","result","emit","values","rewriteError","clear","Disconnected","dispose","close","createSession","targetId","flatten","connection","targetType","_targetType","_sessionId","has","detach","data","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {assert} = require('./helper');\nconst {Events} = require('./Events');\nconst debugProtocol = require('debug')('puppeteer:protocol');\nconst EventEmitter = require('events');\n\nclass Connection extends EventEmitter {\n  /**\n   * @param {string} url\n   * @param {!Puppeteer.ConnectionTransport} transport\n   * @param {number=} delay\n   */\n  constructor(url, transport, delay = 0) {\n    super();\n    this._url = url;\n    this._lastId = 0;\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n    this._callbacks = new Map();\n    this._delay = delay;\n\n    this._transport = transport;\n    this._transport.onmessage = this._onMessage.bind(this);\n    this._transport.onclose = this._onClose.bind(this);\n    /** @type {!Map<string, !CDPSession>}*/\n    this._sessions = new Map();\n    this._closed = false;\n  }\n\n  /**\n   * @param {!CDPSession} session\n   * @return {!Connection}\n   */\n  static fromSession(session) {\n    return session._connection;\n  }\n\n  /**\n   * @param {string} sessionId\n   * @return {?CDPSession}\n   */\n  session(sessionId) {\n    return this._sessions.get(sessionId) || null;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n  send(method, params = {}) {\n    const id = this._rawSend({method, params});\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {resolve, reject, error: new Error(), method});\n    });\n  }\n\n  /**\n   * @param {*} message\n   * @return {number}\n   */\n  _rawSend(message) {\n    const id = ++this._lastId;\n    message = JSON.stringify(Object.assign({}, message, {id}));\n    debugProtocol('SEND ► ' + message);\n    this._transport.send(message);\n    return id;\n  }\n\n  /**\n   * @param {string} message\n   */\n  async _onMessage(message) {\n    if (this._delay)\n      await new Promise(f => setTimeout(f, this._delay));\n    debugProtocol('◀ RECV ' + message);\n    const object = JSON.parse(message);\n    if (object.method === 'Target.attachedToTarget') {\n      const sessionId = object.params.sessionId;\n      const session = new CDPSession(this, object.params.targetInfo.type, sessionId);\n      this._sessions.set(sessionId, session);\n    } else if (object.method === 'Target.detachedFromTarget') {\n      const session = this._sessions.get(object.params.sessionId);\n      if (session) {\n        session._onClosed();\n        this._sessions.delete(object.params.sessionId);\n      }\n    }\n    if (object.sessionId) {\n      const session = this._sessions.get(object.sessionId);\n      if (session)\n        session._onMessage(object);\n    } else if (object.id) {\n      const callback = this._callbacks.get(object.id);\n      // Callbacks could be all rejected if someone has called `.dispose()`.\n      if (callback) {\n        this._callbacks.delete(object.id);\n        if (object.error)\n          callback.reject(createProtocolError(callback.error, callback.method, object));\n        else\n          callback.resolve(object.result);\n      }\n    } else {\n      this.emit(object.method, object.params);\n    }\n  }\n\n  _onClose() {\n    if (this._closed)\n      return;\n    this._closed = true;\n    this._transport.onmessage = null;\n    this._transport.onclose = null;\n    for (const callback of this._callbacks.values())\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    this._callbacks.clear();\n    for (const session of this._sessions.values())\n      session._onClosed();\n    this._sessions.clear();\n    this.emit(Events.Connection.Disconnected);\n  }\n\n  dispose() {\n    this._onClose();\n    this._transport.close();\n  }\n\n  /**\n   * @param {Protocol.Target.TargetInfo} targetInfo\n   * @return {!Promise<!CDPSession>}\n   */\n  async createSession(targetInfo) {\n    const {sessionId} = await this.send('Target.attachToTarget', {targetId: targetInfo.targetId, flatten: true});\n    return this._sessions.get(sessionId);\n  }\n}\n\nclass CDPSession extends EventEmitter {\n  /**\n   * @param {!Connection} connection\n   * @param {string} targetType\n   * @param {string} sessionId\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    /** @type {!Map<number, {resolve: function, reject: function, error: !Error, method: string}>}*/\n    this._callbacks = new Map();\n    this._connection = connection;\n    this._targetType = targetType;\n    this._sessionId = sessionId;\n  }\n\n  /**\n   * @param {string} method\n   * @param {!Object=} params\n   * @return {!Promise<?Object>}\n   */\n  send(method, params = {}) {\n    if (!this._connection)\n      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));\n    const id = this._connection._rawSend({sessionId: this._sessionId, method, params});\n    return new Promise((resolve, reject) => {\n      this._callbacks.set(id, {resolve, reject, error: new Error(), method});\n    });\n  }\n\n  /**\n   * @param {{id?: number, method: string, params: Object, error: {message: string, data: any}, result?: *}} object\n   */\n  _onMessage(object) {\n    if (object.id && this._callbacks.has(object.id)) {\n      const callback = this._callbacks.get(object.id);\n      this._callbacks.delete(object.id);\n      if (object.error)\n        callback.reject(createProtocolError(callback.error, callback.method, object));\n      else\n        callback.resolve(object.result);\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n\n  async detach() {\n    if (!this._connection)\n      throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);\n    await this._connection.send('Target.detachFromTarget',  {sessionId: this._sessionId});\n  }\n\n  _onClosed() {\n    for (const callback of this._callbacks.values())\n      callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));\n    this._callbacks.clear();\n    this._connection = null;\n    this.emit(Events.CDPSession.Disconnected);\n  }\n}\n\n/**\n * @param {!Error} error\n * @param {string} method\n * @param {{error: {message: string, data: any}}} object\n * @return {!Error}\n */\nfunction createProtocolError(error, method, object) {\n  let message = `Protocol error (${method}): ${object.error.message}`;\n  if ('data' in object.error)\n    message += ` ${object.error.data}`;\n  return rewriteError(error, message);\n}\n\n/**\n * @param {!Error} error\n * @param {string} message\n * @return {!Error}\n */\nfunction rewriteError(error, message) {\n  error.message = message;\n  return error;\n}\n\nmodule.exports = {Connection, CDPSession};\n"]},"metadata":{},"sourceType":"module"}