{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst {\n  helper,\n  debugError,\n  assert\n} = require('./helper');\n\nconst {\n  EVALUATION_SCRIPT_URL\n} = require('./ExecutionContext');\n/**\n * @typedef {Object} CoverageEntry\n * @property {string} url\n * @property {string} text\n * @property {!Array<!{start: number, end: number}>} ranges\n */\n\n\nclass Coverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n  /**\n   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options\n   */\n\n\n  async startJSCoverage(options) {\n    return await this._jsCoverage.start(options);\n  }\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n\n\n  async stopJSCoverage() {\n    return await this._jsCoverage.stop();\n  }\n  /**\n   * @param {{resetOnNavigation?: boolean}=} options\n   */\n\n\n  async startCSSCoverage(options) {\n    return await this._cssCoverage.start(options);\n  }\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n\n\n  async stopCSSCoverage() {\n    return await this._cssCoverage.stop();\n  }\n\n}\n\nmodule.exports = {\n  Coverage\n};\n\nclass JSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._scriptURLs = new Map();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n  /**\n   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options\n   */\n\n\n  async start(options = {}) {\n    assert(!this._enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._reportAnonymousScripts = reportAnonymousScripts;\n    this._enabled = true;\n\n    this._scriptURLs.clear();\n\n    this._scriptSources.clear();\n\n    this._eventListeners = [helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)), helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];\n    await Promise.all([this._client.send('Profiler.enable'), this._client.send('Profiler.startPreciseCoverage', {\n      callCount: false,\n      detailed: true\n    }), this._client.send('Debugger.enable'), this._client.send('Debugger.setSkipAllPauses', {\n      skip: true\n    })]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._scriptURLs.clear();\n\n    this._scriptSources.clear();\n  }\n  /**\n   * @param {!Protocol.Debugger.scriptParsedPayload} event\n   */\n\n\n  async _onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === EVALUATION_SCRIPT_URL) return; // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n\n    if (!event.url && !this._reportAnonymousScripts) return;\n\n    try {\n      const response = await this._client.send('Debugger.getScriptSource', {\n        scriptId: event.scriptId\n      });\n\n      this._scriptURLs.set(event.scriptId, event.url);\n\n      this._scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n\n\n  async stop() {\n    assert(this._enabled, 'JSCoverage is not enabled');\n    this._enabled = false;\n    const [profileResponse] = await Promise.all([this._client.send('Profiler.takePreciseCoverage'), this._client.send('Profiler.stopPreciseCoverage'), this._client.send('Profiler.disable'), this._client.send('Debugger.disable')]);\n    helper.removeEventListeners(this._eventListeners);\n    const coverage = [];\n\n    for (const entry of profileResponse.result) {\n      let url = this._scriptURLs.get(entry.scriptId);\n\n      if (!url && this._reportAnonymousScripts) url = 'debugger://VM' + entry.scriptId;\n\n      const text = this._scriptSources.get(entry.scriptId);\n\n      if (text === undefined || url === undefined) continue;\n      const flattenRanges = [];\n\n      for (const func of entry.functions) flattenRanges.push(...func.ranges);\n\n      const ranges = convertToDisjointRanges(flattenRanges);\n      coverage.push({\n        url,\n        ranges,\n        text\n      });\n    }\n\n    return coverage;\n  }\n\n}\n\nclass CSSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n  /**\n   * @param {{resetOnNavigation?: boolean}=} options\n   */\n\n\n  async start(options = {}) {\n    assert(!this._enabled, 'CSSCoverage is already enabled');\n    const {\n      resetOnNavigation = true\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._enabled = true;\n\n    this._stylesheetURLs.clear();\n\n    this._stylesheetSources.clear();\n\n    this._eventListeners = [helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)), helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];\n    await Promise.all([this._client.send('DOM.enable'), this._client.send('CSS.enable'), this._client.send('CSS.startRuleUsageTracking')]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._stylesheetURLs.clear();\n\n    this._stylesheetSources.clear();\n  }\n  /**\n   * @param {!Protocol.CSS.styleSheetAddedPayload} event\n   */\n\n\n  async _onStyleSheet(event) {\n    const header = event.header; // Ignore anonymous scripts\n\n    if (!header.sourceURL) return;\n\n    try {\n      const response = await this._client.send('CSS.getStyleSheetText', {\n        styleSheetId: header.styleSheetId\n      });\n\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n\n\n  async stop() {\n    assert(this._enabled, 'CSSCoverage is not enabled');\n    this._enabled = false;\n    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([this._client.send('CSS.disable'), this._client.send('DOM.disable')]);\n    helper.removeEventListeners(this._eventListeners); // aggregate by styleSheetId\n\n    const styleSheetIdToCoverage = new Map();\n\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0\n      });\n    }\n\n    const coverage = [];\n\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId);\n\n      const text = this._stylesheetSources.get(styleSheetId);\n\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.push({\n        url,\n        ranges,\n        text\n      });\n    }\n\n    return coverage;\n  }\n\n}\n/**\n * @param {!Array<!{startOffset:number, endOffset:number, count:number}>} nestedRanges\n * @return {!Array<!{start:number, end:number}>}\n */\n\n\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  } // Sort points to form a valid parenthesis sequence.\n\n\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) return a.offset - b.offset; // All \"end\" points should go before \"start\" points.\n\n    if (a.type !== b.type) return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset; // For two \"start\" points, the one with longer range goes first.\n\n    if (a.type === 0) return bLength - aLength; // For two \"end\" points, the one with shorter range goes first.\n\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0; // Run scanning line to intersect all ranges.\n\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset) lastResult.end = point.offset;else results.push({\n        start: lastOffset,\n        end: point.offset\n      });\n    }\n\n    lastOffset = point.offset;\n    if (point.type === 0) hitCountStack.push(point.range.count);else hitCountStack.pop();\n  } // Filter out empty ranges.\n\n\n  return results.filter(range => range.end - range.start > 1);\n}","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/puppeteer/lib/Coverage.js"],"names":["helper","debugError","assert","require","EVALUATION_SCRIPT_URL","Coverage","constructor","client","_jsCoverage","JSCoverage","_cssCoverage","CSSCoverage","startJSCoverage","options","start","stopJSCoverage","stop","startCSSCoverage","stopCSSCoverage","module","exports","_client","_enabled","_scriptURLs","Map","_scriptSources","_eventListeners","_resetOnNavigation","resetOnNavigation","reportAnonymousScripts","_reportAnonymousScripts","clear","addEventListener","_onScriptParsed","bind","_onExecutionContextsCleared","Promise","all","send","callCount","detailed","skip","event","url","response","scriptId","set","scriptSource","e","profileResponse","removeEventListeners","coverage","entry","result","get","text","undefined","flattenRanges","func","functions","push","ranges","convertToDisjointRanges","_stylesheetURLs","_stylesheetSources","_onStyleSheet","header","sourceURL","styleSheetId","ruleTrackingResponse","styleSheetIdToCoverage","ruleUsage","startOffset","endOffset","count","used","keys","nestedRanges","points","range","offset","type","sort","a","b","aLength","bLength","hitCountStack","results","lastOffset","point","length","lastResult","end","pop","filter"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {helper, debugError, assert} = require('./helper');\n\nconst {EVALUATION_SCRIPT_URL} = require('./ExecutionContext');\n\n/**\n * @typedef {Object} CoverageEntry\n * @property {string} url\n * @property {string} text\n * @property {!Array<!{start: number, end: number}>} ranges\n */\n\nclass Coverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n\n  /**\n   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options\n   */\n  async startJSCoverage(options) {\n    return await this._jsCoverage.start(options);\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stopJSCoverage() {\n    return await this._jsCoverage.stop();\n  }\n\n  /**\n   * @param {{resetOnNavigation?: boolean}=} options\n   */\n  async startCSSCoverage(options) {\n    return await this._cssCoverage.start(options);\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stopCSSCoverage() {\n    return await this._cssCoverage.stop();\n  }\n}\n\nmodule.exports = {Coverage};\n\nclass JSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._scriptURLs = new Map();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  /**\n   * @param {!{resetOnNavigation?: boolean, reportAnonymousScripts?: boolean}} options\n   */\n  async start(options = {}) {\n    assert(!this._enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._reportAnonymousScripts = reportAnonymousScripts;\n    this._enabled = true;\n    this._scriptURLs.clear();\n    this._scriptSources.clear();\n    this._eventListeners = [\n      helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),\n      helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('Profiler.enable'),\n      this._client.send('Profiler.startPreciseCoverage', {callCount: false, detailed: true}),\n      this._client.send('Debugger.enable'),\n      this._client.send('Debugger.setSkipAllPauses', {skip: true})\n    ]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._scriptURLs.clear();\n    this._scriptSources.clear();\n  }\n\n  /**\n   * @param {!Protocol.Debugger.scriptParsedPayload} event\n   */\n  async _onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === EVALUATION_SCRIPT_URL)\n      return;\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !this._reportAnonymousScripts)\n      return;\n    try {\n      const response = await this._client.send('Debugger.getScriptSource', {scriptId: event.scriptId});\n      this._scriptURLs.set(event.scriptId, event.url);\n      this._scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stop() {\n    assert(this._enabled, 'JSCoverage is not enabled');\n    this._enabled = false;\n    const [profileResponse] = await Promise.all([\n      this._client.send('Profiler.takePreciseCoverage'),\n      this._client.send('Profiler.stopPreciseCoverage'),\n      this._client.send('Profiler.disable'),\n      this._client.send('Debugger.disable'),\n    ]);\n    helper.removeEventListeners(this._eventListeners);\n\n    const coverage = [];\n    for (const entry of profileResponse.result) {\n      let url = this._scriptURLs.get(entry.scriptId);\n      if (!url && this._reportAnonymousScripts)\n        url = 'debugger://VM' + entry.scriptId;\n      const text = this._scriptSources.get(entry.scriptId);\n      if (text === undefined || url === undefined)\n        continue;\n      const flattenRanges = [];\n      for (const func of entry.functions)\n        flattenRanges.push(...func.ranges);\n      const ranges = convertToDisjointRanges(flattenRanges);\n      coverage.push({url, ranges, text});\n    }\n    return coverage;\n  }\n}\n\nclass CSSCoverage {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    this._client = client;\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n  }\n\n  /**\n   * @param {{resetOnNavigation?: boolean}=} options\n   */\n  async start(options = {}) {\n    assert(!this._enabled, 'CSSCoverage is already enabled');\n    const {resetOnNavigation = true} = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._enabled = true;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n    this._eventListeners = [\n      helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),\n      helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n    ];\n    await Promise.all([\n      this._client.send('DOM.enable'),\n      this._client.send('CSS.enable'),\n      this._client.send('CSS.startRuleUsageTracking'),\n    ]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation)\n      return;\n    this._stylesheetURLs.clear();\n    this._stylesheetSources.clear();\n  }\n\n  /**\n   * @param {!Protocol.CSS.styleSheetAddedPayload} event\n   */\n  async _onStyleSheet(event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL)\n      return;\n    try {\n      const response = await this._client.send('CSS.getStyleSheetText', {styleSheetId: header.styleSheetId});\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (e) {\n      // This might happen if the page has already navigated away.\n      debugError(e);\n    }\n  }\n\n  /**\n   * @return {!Promise<!Array<!CoverageEntry>>}\n   */\n  async stop() {\n    assert(this._enabled, 'CSSCoverage is not enabled');\n    this._enabled = false;\n    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([\n      this._client.send('CSS.disable'),\n      this._client.send('DOM.disable'),\n    ]);\n    helper.removeEventListeners(this._eventListeners);\n\n    // aggregate by styleSheetId\n    const styleSheetIdToCoverage = new Map();\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0,\n      });\n    }\n\n    const coverage = [];\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId);\n      const text = this._stylesheetSources.get(styleSheetId);\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.push({url, ranges, text});\n    }\n\n    return coverage;\n  }\n}\n\n/**\n * @param {!Array<!{startOffset:number, endOffset:number, count:number}>} nestedRanges\n * @return {!Array<!{start:number, end:number}>}\n */\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({ offset: range.startOffset, type: 0, range });\n    points.push({ offset: range.endOffset, type: 1, range });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset)\n      return a.offset - b.offset;\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type)\n      return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0)\n      return bLength - aLength;\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset)\n        lastResult.end = point.offset;\n      else\n        results.push({start: lastOffset, end: point.offset});\n    }\n    lastOffset = point.offset;\n    if (point.type === 0)\n      hitCountStack.push(point.range.count);\n    else\n      hitCountStack.pop();\n  }\n  // Filter out empty ranges.\n  return results.filter(range => range.end - range.start > 1);\n}\n\n"]},"metadata":{},"sourceType":"module"}