{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\n\nconst {\n  helper,\n  assert,\n  debugError\n} = require('./helper');\n\nconst {\n  Events\n} = require('./Events');\n\nconst Multimap = require('./Multimap');\n\nclass NetworkManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    super();\n    this._client = client;\n    this._frameManager = null;\n    /** @type {!Map<string, !Request>} */\n\n    this._requestIdToRequest = new Map();\n    /** @type {!Map<string, !Protocol.Network.requestWillBeSentPayload>} */\n\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    /** @type {!Object<string, string>} */\n\n    this._extraHTTPHeaders = {};\n    this._offline = false;\n    /** @type {?{username: string, password: string}} */\n\n    this._credentials = null;\n    /** @type {!Set<string>} */\n\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    /** @type {!Multimap<string, string>} */\n\n    this._requestHashToRequestIds = new Multimap();\n    /** @type {!Multimap<string, string>} */\n\n    this._requestHashToInterceptionIds = new Multimap();\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestIntercepted', this._onRequestIntercepted.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n  /**\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n\n\n  setFrameManager(frameManager) {\n    this._frameManager = frameManager;\n  }\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n\n\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n  /**\n   * @param {!Object<string, string>} extraHTTPHeaders\n   */\n\n\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n\n    await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: this._extraHTTPHeaders\n    });\n  }\n  /**\n   * @return {!Object<string, string>}\n   */\n\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n  /**\n   * @param {boolean} value\n   */\n\n\n  async setOfflineMode(value) {\n    if (this._offline === value) return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n  /**\n   * @param {string} userAgent\n   */\n\n\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', {\n      userAgent\n    });\n  }\n  /**\n   * @param {boolean} value\n   */\n\n\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    const patterns = enabled ? [{\n      urlPattern: '*'\n    }] : [];\n    await Promise.all([this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: enabled\n    }), this._client.send('Network.setRequestInterception', {\n      patterns\n    })]);\n  }\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   */\n\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestHash = generateRequestHash(event.request);\n\n      const interceptionId = this._requestHashToInterceptionIds.firstValue(requestHash);\n\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n\n        this._requestHashToInterceptionIds.delete(requestHash, interceptionId);\n      } else {\n        this._requestHashToRequestIds.set(requestHash, event.requestId);\n\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n  /**\n   * @param {!Protocol.Network.requestInterceptedPayload} event\n   */\n\n\n  _onRequestIntercepted(event) {\n    if (event.authChallenge) {\n      /** @type {\"Default\"|\"CancelAuth\"|\"ProvideCredentials\"} */\n      let response = 'Default';\n\n      if (this._attemptedAuthentications.has(event.interceptionId)) {\n        response = 'CancelAuth';\n      } else if (this._credentials) {\n        response = 'ProvideCredentials';\n\n        this._attemptedAuthentications.add(event.interceptionId);\n      }\n\n      const {\n        username,\n        password\n      } = this._credentials || {\n        username: undefined,\n        password: undefined\n      };\n\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId,\n        authChallengeResponse: {\n          response,\n          username,\n          password\n        }\n      }).catch(debugError);\n\n      return;\n    }\n\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId\n      }).catch(debugError);\n    }\n\n    const requestHash = generateRequestHash(event.request);\n\n    const requestId = this._requestHashToRequestIds.firstValue(requestHash);\n\n    if (requestId) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n\n      this._onRequest(requestWillBeSentEvent, event.interceptionId);\n\n      this._requestHashToRequestIds.delete(requestHash, requestId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestHashToInterceptionIds.set(requestHash, event.interceptionId);\n    }\n  }\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {?string} interceptionId\n   */\n\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId && this._frameManager ? this._frameManager.frame(event.frameId) : null;\n    const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(Events.NetworkManager.Request, request);\n  }\n  /**\n   * @param {!Protocol.Network.requestServedFromCachePayload} event\n   */\n\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n  }\n  /**\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new Response(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._bodyLoadedPromiseFulfill.call(null, new Error('Response body is unavailable for redirect responses'));\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.Response, response);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n  /**\n   * @param {!Protocol.Network.responseReceivedPayload} event\n   */\n\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new Response(this._client, request, event.response);\n    request._response = response;\n    this.emit(Events.NetworkManager.Response, response);\n  }\n  /**\n   * @param {!Protocol.Network.loadingFinishedPayload} event\n   */\n\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._bodyLoadedPromiseFulfill.call(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n  /**\n   * @param {!Protocol.Network.loadingFailedPayload} event\n   */\n\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._bodyLoadedPromiseFulfill.call(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(Events.NetworkManager.RequestFailed, request);\n  }\n\n}\n\nclass Request {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?Puppeteer.Frame} frame\n   * @param {string} interceptionId\n   * @param {boolean} allowInterception\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {!Array<!Request>} redirectChain\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._interceptionHandled = false;\n    this._response = null;\n    this._failureText = null;\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._headers = {};\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n\n    for (const key of Object.keys(event.request.headers)) this._headers[key.toLowerCase()] = event.request.headers[key];\n\n    this._fromMemoryCache = false;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  resourceType() {\n    return this._resourceType;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  method() {\n    return this._method;\n  }\n  /**\n   * @return {string|undefined}\n   */\n\n\n  postData() {\n    return this._postData;\n  }\n  /**\n   * @return {!Object}\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @return {?Response}\n   */\n\n\n  response() {\n    return this._response;\n  }\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n\n\n  frame() {\n    return this._frame;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n  /**\n   * @return {!Array<!Request>}\n   */\n\n\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  /**\n   * @return {?{errorText: string}}\n   */\n\n\n  failure() {\n    if (!this._failureText) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides\n   */\n\n\n  async continue(overrides = {}) {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      url,\n      method,\n      postData,\n      headers\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response\n   */\n\n\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:')) return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    const responseBody = response.body && helper.isString(response.body) ? Buffer.from(\n    /** @type {string} */\n    response.body) :\n    /** @type {?Buffer} */\n    response.body || null;\n    const responseHeaders = {};\n\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n\n    if (response.contentType) responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders)) responseHeaders['content-length'] = Buffer.byteLength(responseBody);\n    const statusCode = response.status || 200;\n    const statusText = statusTexts[statusCode] || '';\n    const statusLine = `HTTP/1.1 ${statusCode} ${statusText}`;\n    const CRLF = '\\r\\n';\n    let text = statusLine + CRLF;\n\n    for (const header of Object.keys(responseHeaders)) text += header + ': ' + responseHeaders[header] + CRLF;\n\n    text += CRLF;\n    let responseBuffer = Buffer.from(text, 'utf8');\n    if (responseBody) responseBuffer = Buffer.concat([responseBuffer, responseBody]);\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      rawResponse: responseBuffer.toString('base64')\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n  /**\n   * @param {string=} errorCode\n   */\n\n\n  async abort(errorCode = 'failed') {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n}\n\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed'\n};\n\nclass Response {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  constructor(client, request, responsePayload) {\n    this._client = client;\n    this._request = request;\n    this._contentPromise = null;\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    };\n    this._status = responsePayload.status;\n    this._statusText = responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this._headers = {};\n\n    for (const key of Object.keys(responsePayload.headers)) this._headers[key.toLowerCase()] = responsePayload.headers[key];\n\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;\n  }\n  /**\n   * @return {{ip: string, port: number}}\n   */\n\n\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  ok() {\n    return this._status === 0 || this._status >= 200 && this._status <= 299;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  status() {\n    return this._status;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  statusText() {\n    return this._statusText;\n  }\n  /**\n   * @return {!Object}\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @return {?SecurityDetails}\n   */\n\n\n  securityDetails() {\n    return this._securityDetails;\n  }\n  /**\n   * @return {!Promise<!Buffer>}\n   */\n\n\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error) throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n\n    return this._contentPromise;\n  }\n  /**\n   * @return {!Promise<string>}\n   */\n\n\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n  /**\n   * @return {!Promise<!Object>}\n   */\n\n\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  /**\n   * @return {!Request}\n   */\n\n\n  request() {\n    return this._request;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n\n\n  frame() {\n    return this._request.frame();\n  }\n\n}\n\nconst IGNORED_HEADERS = new Set(['accept', 'referer', 'x-devtools-emulate-network-conditions-client-id', 'cookie', 'origin', 'content-type', 'intervention']);\n/**\n * @param {!Protocol.Network.Request} request\n * @return {string}\n */\n\nfunction generateRequestHash(request) {\n  let normalizedURL = request.url;\n\n  try {\n    // Decoding is necessary to normalize URLs. @see crbug.com/759388\n    // The method will throw if the URL is malformed. In this case,\n    // consider URL to be normalized as-is.\n    normalizedURL = decodeURI(request.url);\n  } catch (e) {}\n\n  const hash = {\n    url: normalizedURL,\n    method: request.method,\n    postData: request.postData,\n    headers: {}\n  };\n\n  if (!normalizedURL.startsWith('data:')) {\n    const headers = Object.keys(request.headers);\n    headers.sort();\n\n    for (let header of headers) {\n      const headerValue = request.headers[header];\n      header = header.toLowerCase();\n      if (IGNORED_HEADERS.has(header)) continue;\n      hash.headers[header] = headerValue;\n    }\n  }\n\n  return JSON.stringify(hash);\n}\n\nclass SecurityDetails {\n  /**\n   * @param {!Protocol.Network.SecurityDetails} securityPayload\n   */\n  constructor(securityPayload) {\n    this._subjectName = securityPayload['subjectName'];\n    this._issuer = securityPayload['issuer'];\n    this._validFrom = securityPayload['validFrom'];\n    this._validTo = securityPayload['validTo'];\n    this._protocol = securityPayload['protocol'];\n  }\n  /**\n   * @return {string}\n   */\n\n\n  subjectName() {\n    return this._subjectName;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  issuer() {\n    return this._issuer;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  validFrom() {\n    return this._validFrom;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  validTo() {\n    return this._validTo;\n  }\n  /**\n   * @return {string}\n   */\n\n\n  protocol() {\n    return this._protocol;\n  }\n\n}\n\nconst statusTexts = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '209': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};\nmodule.exports = {\n  Request,\n  Response,\n  NetworkManager,\n  SecurityDetails\n};","map":{"version":3,"sources":["/Users/pro/Desktop/Projects/yesume/src/node_test/node_modules/puppeteer/lib/NetworkManager.js"],"names":["EventEmitter","require","helper","assert","debugError","Events","Multimap","NetworkManager","constructor","client","_client","_frameManager","_requestIdToRequest","Map","_requestIdToRequestWillBeSentEvent","_extraHTTPHeaders","_offline","_credentials","_attemptedAuthentications","Set","_userRequestInterceptionEnabled","_protocolRequestInterceptionEnabled","_requestHashToRequestIds","_requestHashToInterceptionIds","on","_onRequestWillBeSent","bind","_onRequestIntercepted","_onRequestServedFromCache","_onResponseReceived","_onLoadingFinished","_onLoadingFailed","setFrameManager","frameManager","authenticate","credentials","_updateProtocolRequestInterception","setExtraHTTPHeaders","extraHTTPHeaders","key","Object","keys","value","isString","toLowerCase","send","headers","assign","setOfflineMode","offline","latency","downloadThroughput","uploadThroughput","setUserAgent","userAgent","setRequestInterception","enabled","patterns","urlPattern","Promise","all","cacheDisabled","event","request","url","startsWith","requestHash","generateRequestHash","interceptionId","firstValue","_onRequest","delete","set","requestId","authChallenge","response","has","add","username","password","undefined","authChallengeResponse","catch","requestWillBeSentEvent","get","redirectChain","redirectResponse","_handleRequestRedirect","_redirectChain","frame","frameId","Request","emit","_fromMemoryCache","responsePayload","Response","_response","push","_bodyLoadedPromiseFulfill","call","Error","_requestId","_interceptionId","RequestFinished","_failureText","errorText","RequestFailed","allowInterception","_isNavigationRequest","loaderId","type","_allowInterception","_interceptionHandled","_url","_resourceType","_method","method","_postData","postData","_headers","_frame","resourceType","isNavigationRequest","slice","failure","continue","overrides","error","respond","responseBody","body","Buffer","from","responseHeaders","header","contentType","byteLength","statusCode","status","statusText","statusTexts","statusLine","CRLF","text","responseBuffer","concat","rawResponse","toString","abort","errorCode","errorReason","errorReasons","_request","_contentPromise","_bodyLoadedPromise","fulfill","_remoteAddress","ip","remoteIPAddress","port","remotePort","_status","_statusText","_fromDiskCache","fromDiskCache","_fromServiceWorker","fromServiceWorker","_securityDetails","securityDetails","SecurityDetails","remoteAddress","ok","buffer","then","base64Encoded","content","json","JSON","parse","fromCache","IGNORED_HEADERS","normalizedURL","decodeURI","e","hash","sort","headerValue","stringify","securityPayload","_subjectName","_issuer","_validFrom","_validTo","_protocol","subjectName","issuer","validFrom","validTo","protocol","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter = require('events');\nconst {helper, assert, debugError} = require('./helper');\nconst {Events} = require('./Events');\nconst Multimap = require('./Multimap');\n\nclass NetworkManager extends EventEmitter {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   */\n  constructor(client) {\n    super();\n    this._client = client;\n    this._frameManager = null;\n    /** @type {!Map<string, !Request>} */\n    this._requestIdToRequest = new Map();\n    /** @type {!Map<string, !Protocol.Network.requestWillBeSentPayload>} */\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    /** @type {!Object<string, string>} */\n    this._extraHTTPHeaders = {};\n\n    this._offline = false;\n\n    /** @type {?{username: string, password: string}} */\n    this._credentials = null;\n    /** @type {!Set<string>} */\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    /** @type {!Multimap<string, string>} */\n    this._requestHashToRequestIds = new Multimap();\n    /** @type {!Multimap<string, string>} */\n    this._requestHashToInterceptionIds = new Multimap();\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n    this._client.on('Network.requestIntercepted', this._onRequestIntercepted.bind(this));\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  /**\n   * @param {!Puppeteer.FrameManager} frameManager\n   */\n  setFrameManager(frameManager) {\n    this._frameManager = frameManager;\n  }\n\n  /**\n   * @param {?{username: string, password: string}} credentials\n   */\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  /**\n   * @param {!Object<string, string>} extraHTTPHeaders\n   */\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert(helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n    await this._client.send('Network.setExtraHTTPHeaders', { headers: this._extraHTTPHeaders });\n  }\n\n  /**\n   * @return {!Object<string, string>}\n   */\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setOfflineMode(value) {\n    if (this._offline === value)\n      return;\n    this._offline = value;\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._offline,\n      // values of 0 remove any active throttling. crbug.com/456324#c9\n      latency: 0,\n      downloadThroughput: -1,\n      uploadThroughput: -1\n    });\n  }\n\n  /**\n   * @param {string} userAgent\n   */\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', { userAgent });\n  }\n\n  /**\n   * @param {boolean} value\n   */\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled)\n      return;\n    this._protocolRequestInterceptionEnabled = enabled;\n    const patterns = enabled ? [{urlPattern: '*'}] : [];\n    await Promise.all([\n      this._client.send('Network.setCacheDisabled', {cacheDisabled: enabled}),\n      this._client.send('Network.setRequestInterception', {patterns})\n    ]);\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   */\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestHash = generateRequestHash(event.request);\n      const interceptionId = this._requestHashToInterceptionIds.firstValue(requestHash);\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n        this._requestHashToInterceptionIds.delete(requestHash, interceptionId);\n      } else {\n        this._requestHashToRequestIds.set(requestHash, event.requestId);\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n      return;\n    }\n    this._onRequest(event, null);\n  }\n\n  /**\n   * @param {!Protocol.Network.requestInterceptedPayload} event\n   */\n  _onRequestIntercepted(event) {\n    if (event.authChallenge) {\n      /** @type {\"Default\"|\"CancelAuth\"|\"ProvideCredentials\"} */\n      let response = 'Default';\n      if (this._attemptedAuthentications.has(event.interceptionId)) {\n        response = 'CancelAuth';\n      } else if (this._credentials) {\n        response = 'ProvideCredentials';\n        this._attemptedAuthentications.add(event.interceptionId);\n      }\n      const {username, password} = this._credentials || {username: undefined, password: undefined};\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId,\n        authChallengeResponse: { response, username, password }\n      }).catch(debugError);\n      return;\n    }\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Network.continueInterceptedRequest', {\n        interceptionId: event.interceptionId\n      }).catch(debugError);\n    }\n\n    const requestHash = generateRequestHash(event.request);\n    const requestId = this._requestHashToRequestIds.firstValue(requestHash);\n    if (requestId) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n      this._onRequest(requestWillBeSentEvent, event.interceptionId);\n      this._requestHashToRequestIds.delete(requestHash, requestId);\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestHashToInterceptionIds.set(requestHash, event.interceptionId);\n    }\n  }\n\n  /**\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {?string} interceptionId\n   */\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId);\n      // If we connect late to the target, we could have missed the requestWillBeSent event.\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n        redirectChain = request._redirectChain;\n      }\n    }\n    const frame = event.frameId && this._frameManager ? this._frameManager.frame(event.frameId) : null;\n    const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n    this._requestIdToRequest.set(event.requestId, request);\n    this.emit(Events.NetworkManager.Request, request);\n  }\n\n\n  /**\n   * @param {!Protocol.Network.requestServedFromCachePayload} event\n   */\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    if (request)\n      request._fromMemoryCache = true;\n  }\n\n  /**\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new Response(this._client, request, responsePayload);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._bodyLoadedPromiseFulfill.call(null, new Error('Response body is unavailable for redirect responses'));\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.Response, response);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.responseReceivedPayload} event\n   */\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request)\n      return;\n    const response = new Response(this._client, request, event.response);\n    request._response = response;\n    this.emit(Events.NetworkManager.Response, response);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFinishedPayload} event\n   */\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response())\n      request.response()._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.RequestFinished, request);\n  }\n\n  /**\n   * @param {!Protocol.Network.loadingFailedPayload} event\n   */\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request)\n      return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response)\n      response._bodyLoadedPromiseFulfill.call(null);\n    this._requestIdToRequest.delete(request._requestId);\n    this._attemptedAuthentications.delete(request._interceptionId);\n    this.emit(Events.NetworkManager.RequestFailed, request);\n  }\n}\n\nclass Request {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {?Puppeteer.Frame} frame\n   * @param {string} interceptionId\n   * @param {boolean} allowInterception\n   * @param {!Protocol.Network.requestWillBeSentPayload} event\n   * @param {!Array<!Request>} redirectChain\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._interceptionHandled = false;\n    this._response = null;\n    this._failureText = null;\n\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._headers = {};\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n    for (const key of Object.keys(event.request.headers))\n      this._headers[key.toLowerCase()] = event.request.headers[key];\n\n    this._fromMemoryCache = false;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {string}\n   */\n  resourceType() {\n    return this._resourceType;\n  }\n\n  /**\n   * @return {string}\n   */\n  method() {\n    return this._method;\n  }\n\n  /**\n   * @return {string|undefined}\n   */\n  postData() {\n    return this._postData;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?Response}\n   */\n  response() {\n    return this._response;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._frame;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n\n  /**\n   * @return {!Array<!Request>}\n   */\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n\n  /**\n   * @return {?{errorText: string}}\n   */\n  failure() {\n    if (!this._failureText)\n      return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n\n  /**\n   * @param {!{url?: string, method?:string, postData?: string, headers?: !Object}} overrides\n   */\n  async continue(overrides = {}) {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:'))\n      return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      url,\n      method,\n      postData,\n      headers,\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {!{status: number, headers: Object, contentType: string, body: (string|Buffer)}} response\n   */\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:'))\n      return;\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n\n    const responseBody = response.body && helper.isString(response.body) ? Buffer.from(/** @type {string} */(response.body)) : /** @type {?Buffer} */(response.body || null);\n\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers))\n        responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n    if (response.contentType)\n      responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders))\n      responseHeaders['content-length'] = Buffer.byteLength(responseBody);\n\n    const statusCode = response.status || 200;\n    const statusText = statusTexts[statusCode] || '';\n    const statusLine = `HTTP/1.1 ${statusCode} ${statusText}`;\n\n    const CRLF = '\\r\\n';\n    let text = statusLine + CRLF;\n    for (const header of Object.keys(responseHeaders))\n      text += header + ': ' + responseHeaders[header] + CRLF;\n    text += CRLF;\n    let responseBuffer = Buffer.from(text, 'utf8');\n    if (responseBody)\n      responseBuffer = Buffer.concat([responseBuffer, responseBody]);\n\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      rawResponse: responseBuffer.toString('base64')\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n\n  /**\n   * @param {string=} errorCode\n   */\n  async abort(errorCode = 'failed') {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:'))\n      return;\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Network.continueInterceptedRequest', {\n      interceptionId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was already canceled\n      // or the page was closed. We should tolerate these errors.\n      debugError(error);\n    });\n  }\n}\n\nconst errorReasons = {\n  'aborted': 'Aborted',\n  'accessdenied': 'AccessDenied',\n  'addressunreachable': 'AddressUnreachable',\n  'blockedbyclient': 'BlockedByClient',\n  'blockedbyresponse': 'BlockedByResponse',\n  'connectionaborted': 'ConnectionAborted',\n  'connectionclosed': 'ConnectionClosed',\n  'connectionfailed': 'ConnectionFailed',\n  'connectionrefused': 'ConnectionRefused',\n  'connectionreset': 'ConnectionReset',\n  'internetdisconnected': 'InternetDisconnected',\n  'namenotresolved': 'NameNotResolved',\n  'timedout': 'TimedOut',\n  'failed': 'Failed',\n};\n\nclass Response {\n  /**\n   * @param {!Puppeteer.CDPSession} client\n   * @param {!Request} request\n   * @param {!Protocol.Network.Response} responsePayload\n   */\n  constructor(client, request, responsePayload) {\n    this._client = client;\n    this._request = request;\n    this._contentPromise = null;\n\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort,\n    };\n    this._status = responsePayload.status;\n    this._statusText = responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this._headers = {};\n    for (const key of Object.keys(responsePayload.headers))\n      this._headers[key.toLowerCase()] = responsePayload.headers[key];\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;\n  }\n\n  /**\n   * @return {{ip: string, port: number}}\n   */\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n\n  /**\n   * @return {string}\n   */\n  url() {\n    return this._url;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  ok() {\n    return this._status === 0 || (this._status >= 200 && this._status <= 299);\n  }\n\n  /**\n   * @return {number}\n   */\n  status() {\n    return this._status;\n  }\n\n  /**\n   * @return {string}\n   */\n  statusText() {\n    return this._statusText;\n  }\n\n  /**\n   * @return {!Object}\n   */\n  headers() {\n    return this._headers;\n  }\n\n  /**\n   * @return {?SecurityDetails}\n   */\n  securityDetails() {\n    return this._securityDetails;\n  }\n\n  /**\n   * @return {!Promise<!Buffer>}\n   */\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error)\n          throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n    return this._contentPromise;\n  }\n\n  /**\n   * @return {!Promise<string>}\n   */\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n\n  /**\n   * @return {!Promise<!Object>}\n   */\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n\n  /**\n   * @return {!Request}\n   */\n  request() {\n    return this._request;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n\n  /**\n   * @return {?Puppeteer.Frame}\n   */\n  frame() {\n    return this._request.frame();\n  }\n}\n\nconst IGNORED_HEADERS = new Set(['accept', 'referer', 'x-devtools-emulate-network-conditions-client-id', 'cookie', 'origin', 'content-type', 'intervention']);\n\n/**\n * @param {!Protocol.Network.Request} request\n * @return {string}\n */\nfunction generateRequestHash(request) {\n  let normalizedURL = request.url;\n  try {\n    // Decoding is necessary to normalize URLs. @see crbug.com/759388\n    // The method will throw if the URL is malformed. In this case,\n    // consider URL to be normalized as-is.\n    normalizedURL = decodeURI(request.url);\n  } catch (e) {\n  }\n  const hash = {\n    url: normalizedURL,\n    method: request.method,\n    postData: request.postData,\n    headers: {},\n  };\n\n  if (!normalizedURL.startsWith('data:')) {\n    const headers = Object.keys(request.headers);\n    headers.sort();\n    for (let header of headers) {\n      const headerValue = request.headers[header];\n      header = header.toLowerCase();\n      if (IGNORED_HEADERS.has(header))\n        continue;\n      hash.headers[header] = headerValue;\n    }\n  }\n  return JSON.stringify(hash);\n}\n\nclass SecurityDetails {\n  /**\n   * @param {!Protocol.Network.SecurityDetails} securityPayload\n   */\n  constructor(securityPayload) {\n    this._subjectName = securityPayload['subjectName'];\n    this._issuer = securityPayload['issuer'];\n    this._validFrom = securityPayload['validFrom'];\n    this._validTo = securityPayload['validTo'];\n    this._protocol = securityPayload['protocol'];\n  }\n\n  /**\n   * @return {string}\n   */\n  subjectName() {\n    return this._subjectName;\n  }\n\n  /**\n   * @return {string}\n   */\n  issuer() {\n    return this._issuer;\n  }\n\n  /**\n   * @return {number}\n   */\n  validFrom() {\n    return this._validFrom;\n  }\n\n  /**\n   * @return {number}\n   */\n  validTo() {\n    return this._validTo;\n  }\n\n  /**\n   * @return {string}\n   */\n  protocol() {\n    return this._protocol;\n  }\n}\n\nconst statusTexts = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '209': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': 'I\\'m a teapot',\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required',\n};\n\nmodule.exports = {Request, Response, NetworkManager, SecurityDetails};\n"]},"metadata":{},"sourceType":"module"}